ПРАВИЛА ДЛЯ НЕЙРОСЕТЕЙ (важно для качества ответов):
- Язык ответов: по умолчанию RU. Английский — если явно попросят или в именах/терминах.
- Всегда начинай с полного и детального анализа всего приложения.
- Всегда указывай точные пути файлов при ссылках (например, src/app/(main)/timeline/page.tsx).
- Любой код выводи ТОЛЬКО в тройных бэктиках с указанием языка, например:
  ```ts
  export function x() {}
  ```
- Не используй тяжелое форматирование. Разрешены: списки, короткие таблицы.
- Если требуются изменения в файле — показывай минимальный патч (unified diff) или целиком обновлённый файл (не смешивать).
- Не выдумывай зависимости и API. Если данных нет — явно скажи «нужно уточнение».
- Учитывай что я работаю через web интерфейс github.com и не возможности локально делать проект.
- Стиль кода: TypeScript strict, ESM-импорты, 2 пробела.
- НИКОГДА не генерируй весь файл project-full целиком; только блоки для замены со строгим указанием места.
- Формат изменений: -> ФАЙЛ: путь -> НАЙТИ: [фрагмент дословно] -> ЗАМЕНИТЬ НА: [полный новый блок].
- Если какой то файл приложения требует полной замены, то присылай именно этого файла полный и правильный (соответствующий моему проекту) файл который этого требует. 
- Сохраняй комментарии, форматирование и импорт-структуру.
- Если удаляем блок — укажи строку перед и строку после (из реального кода).
- Всегда пиши краткое обоснование, что и почему делаем.
- Очень важно! Прервать воспроизведение могут только кнопки Пауза, стоп и срабатывание таймера, при всех остальных сценариях какие бы не были плеер всегда играет и на всех устройствах, ничего другого его не может остановить или сбросить или отключить звук, вообще никакая другая функция - это базовое правило этого проигрывателя.
- Всегда предлагай список дальнейших улучшений и критических ошибок если они встречаются во всей программе при анализе.

Название репозитория: vi3na1bita-music
Адрес репозитория: https://github.com/apel-s-in/vi3na1bita-music
# ПОЛНЫЙ И ДЕТАЛЬНЫЙ АНАЛИЗ ПРИЛОЖЕНИЯ.
Проект делается и обслуживается средствами https://github.com/ (GitHub Pages + GitHub Actions).

СТРУКТУРА ПРОЕКТА:
vi3na1bita-music/
├── .git/
│   ├── hooks/
│   │   ├── applypatch-msg.sample
│   │   ├── commit-msg.sample
│   │   ├── fsmonitor-watchman.sample
│   │   ├── post-update.sample
│   │   ├── pre-applypatch.sample
│   │   ├── pre-commit.sample
│   │   ├── pre-merge-commit.sample
│   │   ├── pre-push.sample
│   │   ├── pre-rebase.sample
│   │   ├── pre-receive.sample
│   │   ├── prepare-commit-msg.sample
│   │   ├── push-to-checkout.sample
│   │   ├── sendemail-validate.sample
│   │   └── update.sample
│   ├── info/
│   │   └── exclude
│   ├── logs/
│   │   ├── refs/
│   │   │   ├── heads/
│   │   │   │   └── main
│   │   │   └── remotes/
│   │   │       └── origin/
│   │   │           └── main
│   │   └── HEAD
│   ├── objects/
│   │   ├── info/
│   │   └── pack/
│   │       ├── pack-f353a4049fa0039b5807427b10c7f05c6b757a4c.idx
│   │       ├── pack-f353a4049fa0039b5807427b10c7f05c6b757a4c.pack
│   │       └── pack-f353a4049fa0039b5807427b10c7f05c6b757a4c.rev
│   ├── refs/
│   │   ├── heads/
│   │   │   └── main
│   │   ├── remotes/
│   │   │   └── origin/
│   │   │       └── main
│   │   └── tags/
│   ├── config
│   ├── config.worktree
│   ├── description
│   ├── FETCH_HEAD
│   ├── HEAD
│   └── index
├── .github/
│   └── workflows/
│       ├── e2e.yml
│       ├── generate-context.yml
│       └── validate.yml
├── .meta/
│   └── .gitkeep
├── albums/
│   ├── gallery/
│   │   ├── 00/
│   │   │   ├── 00-cover-01.jpg
│   │   │   ├── 00-cover-01.png
│   │   │   ├── 00-cover-01.webp
│   │   │   ├── 00-cover-02.jpg
│   │   │   ├── 00-cover-02.png
│   │   │   ├── 00-cover-02.webp
│   │   │   └── index.json
│   │   ├── 01/
│   │   │   ├── 01-cover-01.jpg
│   │   │   ├── 01-cover-01.png
│   │   │   ├── 01-cover-01.webp
│   │   │   ├── 01-cover-02.jpg
│   │   │   ├── 01-cover-02.png
│   │   │   ├── 01-cover-02.webp
│   │   │   ├── 01-cover-03.jpg
│   │   │   ├── 01-cover-03.png
│   │   │   ├── 01-cover-03.webp
│   │   │   ├── 01-cover-04.jpg
│   │   │   ├── 01-cover-04.png
│   │   │   ├── 01-cover-04.webp
│   │   │   └── index.json
│   │   ├── 02/
│   │   │   ├── 02-cover-01.jpg
│   │   │   ├── 02-cover-01.png
│   │   │   ├── 02-cover-01.webp
│   │   │   ├── 02-cover-02.jpg
│   │   │   ├── 02-cover-02.png
│   │   │   ├── 02-cover-02.webp
│   │   │   ├── 02-cover-03.jpg
│   │   │   ├── 02-cover-03.png
│   │   │   ├── 02-cover-03.webp
│   │   │   ├── 02-cover-04.jpg
│   │   │   ├── 02-cover-04.png
│   │   │   ├── 02-cover-04.webp
│   │   │   └── index.json
│   │   └── news/
│   │       ├── thumbs/
│   │       │   ├── news-cover-02-thumb.jpg
│   │       │   └── news-cover-02-thumb.webp
│   │       ├── index.json
│   │       ├── news-01-baner.html
│   │       ├── news-cover-02.avif
│   │       ├── news-cover-02.png
│   │       └── news-cover-02.webp
│   └── .gitkeep
├── assets/
│   ├── emoji/
│   │   └── noto/
│   │       ├── animated/
│   │       │   ├── cross_mark.json
│   │       │   ├── loudspeaker.json
│   │       │   ├── satellite_antenna.json
│   │       │   ├── sparkles.json
│   │       │   ├── trophy.json
│   │       │   ├── warning.json
│   │       │   └── white_check_mark.json
│   │       ├── fallback/
│   │       │   ├── cross_mark.webp
│   │       │   ├── loudspeaker.webp
│   │       │   ├── satellite_antenna.webp
│   │       │   ├── sparkles.webp
│   │       │   ├── trophy.webp
│   │       │   ├── warning.webp
│   │       │   └── white_check_mark.webp
│   │       └── static/
│   │           ├── cross_mark.png
│   │           ├── loudspeaker.png
│   │           ├── satellite_antenna.png
│   │           ├── sparkles.png
│   │           ├── trophy.png
│   │           ├── warning.png
│   │           └── white_check_mark.png
│   └── .gitkeep
├── icons/
│   ├── .gitkeep
│   ├── apple-touch-icon.png
│   ├── favicon-16.png
│   ├── favicon-32.png
│   ├── icon-192.png
│   └── icon-512.png
├── img/
│   ├── desktop/
│   │   ├── logo@1x.png
│   │   ├── logo@2x.png
│   │   └── logo@3x.png
│   ├── icon_album/
│   │   ├── mobile/
│   │   │   ├── icon-album-00@1x.jpg
│   │   │   ├── icon-album-00@2x.jpg
│   │   │   ├── icon-album-01@1x.jpg
│   │   │   ├── icon-album-01@2x.jpg
│   │   │   ├── icon-album-02@1x.jpg
│   │   │   ├── icon-album-02@2x.jpg
│   │   │   ├── icon-album-news@1x.jpg
│   │   │   ├── icon-album-news@2x.jpg
│   │   │   ├── icon-album+00@1x.jpg
│   │   │   └── icon-album+00@2x.jpg
│   │   ├── icon-album-00.png
│   │   ├── icon-album-00@1x.png
│   │   ├── icon-album-00@2x.png
│   │   ├── icon-album-01.png
│   │   ├── icon-album-01@1x.png
│   │   ├── icon-album-01@2x.png
│   │   ├── icon-album-02.png
│   │   ├── icon-album-02@1x.png
│   │   ├── icon-album-02@2x.png
│   │   ├── icon-album-news.png
│   │   ├── icon-album-news@1x.png
│   │   ├── icon-album-news@2x.png
│   │   ├── icon-album+00.png
│   │   ├── icon-album+00@1x.png
│   │   └── icon-album+00@2x.png
│   ├── mobile/
│   │   ├── logo@1x.jpg
│   │   └── logo@2x.jpg
│   ├── .gitkeep
│   ├── bg.png
│   ├── logo.png
│   ├── prize-01.png
│   ├── prize-02.png
│   ├── prize-03.png
│   ├── prize-04.png
│   ├── prize-21.png
│   ├── prize-22.png
│   ├── prize-23.png
│   ├── prize-24.png
│   ├── star.png
│   └── star2.png
├── news/
│   ├── .gitkeep
│   └── news.json
├── performance/
│   └── rum.js
├── scripts/
│   ├── app/
│   │   ├── albums.js
│   │   ├── background-audio.js
│   │   ├── background-events.js
│   │   ├── downloads.js
│   │   ├── navigation.js
│   │   └── player-controls.js
│   ├── ci/
│   │   ├── lint-sw.mjs
│   │   ├── validate-content.mjs
│   │   ├── validate-manifest.mjs
│   │   └── validate-playercore.mjs
│   ├── core/
│   │   ├── bootstrap.js
│   │   └── config.js
│   ├── e2e/
│   │   ├── favorites.spec.js
│   │   └── player.spec.js
│   ├── ui/
│   │   ├── favorites-const.js
│   │   ├── favorites-data.js
│   │   ├── favorites-storage.js
│   │   ├── favorites.js
│   │   ├── mini.js
│   │   ├── modals.js
│   │   ├── notify.js
│   │   ├── sleep.js
│   │   └── sysinfo.js
│   ├── app.js
│   ├── energy.js
│   └── player-adapter.js
├── src/
│   ├── .gitkeep
│   ├── PlayerCore.js
│   └── PlayerCore.ts
├── styles/
│   └── main.css
├── albums.json
├── custom.json
├── generate-context.js
├── index.html
├── manifest.json
├── news.html
└── service-worker.js


Сгенерировано: 2025-12-06 20:21:49 UTC
//=================================================
// FILE: /.github/workflows/e2e.yml
name: E2E smoke

on:
  push:
    branches: [ main, master ]
  pull_request:

jobs:
  e2e:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Playwright
        run: npx -y playwright@1.48.2 install --with-deps

      - name: Start static server
        run: |
          npx -y http-server -p 4173 -c-1 . &
          echo $! > server.pid
          sleep 2

      - name: Run smoke tests
        env:
          BASE_URL: http://127.0.0.1:4173
        run: npx -y @playwright/test@1.48.2 scripts/e2e

      - name: Stop server
        if: always()
        run: kill $(cat server.pid) || true

//=================================================
// FILE: /.github/workflows/generate-context.yml
name: Generate .meta context

on:
  push:
    branches: [ main, master ]
    # не перезапускать воркфлоу от собственных коммитов, меняющих только .meta
    paths-ignore:
      - '.meta/**'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  meta:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Generate .meta
        run: |
          node generate-context.js --mode=both --max-lines=20000
          ls -la .meta || true

      - name: Commit .meta
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "CI: generate .meta context"
          branch: ${{ github.ref_name }}
          file_pattern: ".meta/**"
          commit_user_name: github-actions[bot]
          commit_user_email: github-actions[bot]@users.noreply.github.com

//=================================================
// FILE: /.github/workflows/validate.yml
name: Validate manifest and SW

on:
  push:
    branches: [ main, master ]
  pull_request:

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Run manifest validator
        run: node scripts/ci/validate-manifest.mjs

      - name: Run SW linter
        run: node scripts/ci/lint-sw.mjs

      - name: Validate albums and galleries
        run: node scripts/ci/validate-content.mjs

      - name: Validate PlayerCore JS/TS agreement
        run: node scripts/ci/validate-playercore.mjs


//=================================================
// FILE: /albums.json
{
  "albums": [
    {
      "key": "mezhdu-zlom-i-dobrom",
      "title": "Между Злом и Добром (2025)",
      "base": "https://apel-s-in.github.io/vi3na1bita-mezhdu-zlom-i-dobrom/"
    },
    {
      "key": "golos-dushi",
      "title": "Голос Души",
      "base": "https://apel-s-in.github.io/vi3na1bita-golos-dushi/"
    },
    {
      "key": "krevetochka",
      "title": "КРЕВЕツTOCHKA",
      "base": "https://apel-s-in.github.io/krevetochka/"
    }
  ]
}

//=================================================
// FILE: /albums/gallery/00/index.json
{
  "items": [
    {
      "formats": {
        "webp": "albums/gallery/00/00-cover-01.webp",
        "full": "albums/gallery/00/00-cover-01.png"
      }
    },
    {
      "formats": {
        "webp": "albums/gallery/00/00-cover-02.webp",
        "full": "albums/gallery/00/00-cover-02.png"
      }
    }
  ]
}

//=================================================
// FILE: /albums/gallery/01/index.json
{
  "items": [
    {
      "formats": {
        "webp": "albums/gallery/01/01-cover-01.webp",
        "full": "albums/gallery/01/01-cover-01.png"
      }
    },
    {
      "formats": {
        "webp": "albums/gallery/01/01-cover-02.webp",
        "full": "albums/gallery/01/01-cover-02.png"
      }
    },
    {
      "formats": {
        "webp": "albums/gallery/01/01-cover-03.webp",
        "full": "albums/gallery/01/01-cover-03.png"
      }
    },
    {
      "formats": {
        "webp": "albums/gallery/01/01-cover-04.webp",
        "full": "albums/gallery/01/01-cover-04.png"
      }
    }
  ]
}

//=================================================
// FILE: /albums/gallery/02/index.json
{
  "items": [
    {
      "formats": {
        "webp": "albums/gallery/02/02-cover-01.webp",
        "full": "albums/gallery/02/02-cover-01.png"
      }
    },
    {
      "formats": {
        "webp": "albums/gallery/02/02-cover-02.webp",
        "full": "albums/gallery/02/02-cover-02.png"
      }
    },
    {
      "formats": {
        "webp": "albums/gallery/02/02-cover-03.webp",
        "full": "albums/gallery/02/02-cover-03.png"
      }
    },
    {
      "formats": {
        "webp": "albums/gallery/02/02-cover-04.webp",
        "full": "albums/gallery/02/02-cover-04.png"
      }
    }
  ]
}

//=================================================
// FILE: /albums/gallery/news/index.json
{
  "items": [
    { "type": "html", "src": "albums/gallery/news/news-01-baner.html" },
    {
      "formats": {
        "webp": "albums/gallery/news/news-cover-02.webp",
        "full": "albums/gallery/news/news-cover-02.png"
      }
    }
  ]
}

//=================================================
// FILE: /custom.json
{
  "rumEndpoint": "",
  "sw": {
    "mediaMaxCacheMB": 150,
    "nonRangeMaxStoreMB": 25,
    "nonRangeMaxStoreMBSlow": 10,
    "allowUnknownSize": false,
    "revalidateDays": 7
  },
  "items": [
    {
      "type": "ym",
      "title": "Исполнитель — Витрина Разбита",
      "subtitle": "Яндекс Музыка",
      "url": "https://music.yandex.ru/artist/24739002?utm_source=web&utm_medium=copy_link",
      "cover": ""
    },
    {
      "type": "tgPost",
      "title": "Свежий пост в Telegram",
      "url": "https://t.me/vitrina_razbita/28",
      "height": 480
    },
    {
      "type": "vkPlaylist",
      "title": "Альбом «Голос Души» (VK)",
      "ownerId": 165137,
      "playlistId": 3,
      "hash": "b8300406c5f33725de",
      "containerId": "vk_playlist_165137_3"
    },
    {
      "type": "vkPlaylist",
      "title": "Альбом «Между Злом и Добром» (VK)",
      "ownerId": 165137,
      "playlistId": 2,
      "hash": "d70fba309dc0bea296",
      "containerId": "vk_playlist_165137_2"
    }
  ]
}

//=================================================
// FILE: /index.html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Витрина Разбита</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="description" content="Официальные альбомы группы Витрина Разбита. Слушайте онлайн и офлайн.">

  <!-- PWA -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#181818" />

  <!-- iOS -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Витрина Разбита">
  <link rel="apple-touch-icon" href="icons/apple-touch-icon.png">

  <!-- Preload -->
  <link rel="preload" href="img/logo.png" as="image">

  <!-- Favicons -->
  <link rel="icon" href="icons/favicon-32.png" sizes="32x32" type="image/png">
  <link rel="apple-touch-icon" href="icons/apple-touch-icon.png">

  <link rel="stylesheet" href="styles/main.css">
  
  <script src="./performance/rum.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/howler@2.2.4/dist/howler.core.min.js"></script>
  
  <!-- Core modules -->
  <script src="./scripts/core/bootstrap.js" defer></script>
  <script src="./scripts/core/config.js" type="module"></script>
  
  <!-- UI modules -->
  <script src="./scripts/ui/notify.js" defer></script>
  <script src="./scripts/ui/favorites-const.js"></script>
  <script src="./scripts/ui/favorites-storage.js"></script>
  <script src="./scripts/ui/favorites-data.js" defer></script>
  <script src="./scripts/ui/favorites.js" defer></script>
  <script src="./scripts/ui/mini.js" defer></script>
  <script src="./scripts/ui/sysinfo.js" defer></script>
  
  <!-- App modules -->
  <script src="./scripts/app/background-audio.js" defer></script>
  <script src="./scripts/app/background-events.js" defer></script>
  <script src="./scripts/app/player-controls.js" defer></script>
  <script src="./scripts/app/albums.js" type="module"></script>
  <script src="./scripts/app/navigation.js" type="module"></script>
  <script src="./scripts/app/downloads.js" type="module"></script>
  
  <!-- Main app -->
  <script src="./scripts/app.js" type="module"></script>
</head>
<body>
  <!-- Promocode -->
  <div id="promocode-block">
    <div class="promo-inner">
      <img class="promo-cover" id="promo-cover" src="img/logo.png" alt="Обложка" draggable="false"/>
      <h2>Вход по промокоду</h2>
      <input id="promo-inp" type="text" placeholder="Введите промокод" autocomplete="off" autofocus />
      <button id="promo-btn">Войти</button>
      <div id="promo-error"></div>
    </div>
  </div>

  <!-- Main app -->
  <div id="main-block" class="hidden">
    <header>
      <div id="active-album-title" class="active-album-title">—</div>
      <div id="album-icons" class="album-icons" aria-label="Альбомы"></div>
      
      <div id="cover-wrap">
        <button class="cover-gallery-arrow" id="cover-gallery-arrow-left" title="Назад" aria-label="Предыдущая обложка">
          <svg width="34" height="34" viewBox="0 0 34 34"><circle cx="17" cy="17" r="16" fill="#23252e" opacity="0.65"/><polyline points="20,10 13,17 20,24" fill="none" stroke="#fff" stroke-width="2.9" stroke-linecap="round" stroke-linejoin="round"/></svg>
        </button>
        <div id="cover-slot" aria-label="Обложка альбома"></div>
        <button class="cover-gallery-arrow" id="cover-gallery-arrow-right" title="Вперёд" aria-label="Следующая обложка">
          <svg width="34" height="34" viewBox="0 0 34 34"><circle cx="17" cy="17" r="16" fill="#23252e" opacity="0.65"/><polyline points="14,10 21,17 14,24" fill="none" stroke="#fff" stroke-width="2.9" stroke-linecap="round" stroke-linejoin="round"/></svg>
        </button>
      </div>

      <div id="social-links" class="socials-under-cover"></div>
    </header>

    <div id="now-playing"></div>
    <div class="track-list" id="track-list"></div>

    <div class="bottom-controls-center">
      <button class="filter-favorites-btn" id="filter-favorites-btn">Скрыть не отмеченные ⭐ песни</button>
      <img class="logo-bottom" id="logo-bottom" src="img/logo.png" alt="Логотип"/>
      <button id="install-pwa-btn" style="display: none;">УСТАНОВИТЬ КАК ПРИЛОЖЕНИЕ</button>
      <button id="download-album-main">СКАЧАТЬ ВЕСЬ АЛЬБОМ</button>
      <button class="hotkeys-btn" id="hotkeys-btn" style="display:none;">ГОРЯЧИЕ КЛАВИШИ</button>
      <button class="hotkeys-btn" id="sysinfo-btn" style="display:none;">О СИСТЕМЕ</button>
      <span class="feedback-link" id="feedback-link">ОБРАТНАЯ СВЯЗЬ</span>
      <a class="support-link" id="support-link" href="#" target="_blank">ПОДДЕРЖАТЬ</a>
      <button class="offline-btn online" id="offline-btn">ONLINE</button>
    </div>
  </div>

  <!-- Modals container -->
  <div id="modals-container"></div>
</body>
</html>

//=================================================
// FILE: /manifest.json
{
  "name": "Витрина Разбита",
  "short_name": "Витрина",
  "start_url": "./",
  "scope": "./",
  "display": "standalone",
  "background_color": "#181818",
  "theme_color": "#181818",
  "description": "Официальные альбомы группы Витрина Разбита. Слушайте онлайн и офлайн.",
  "icons": [
    {
      "src": "icons/icon-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "icons/icon-512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "icons/apple-touch-icon.png",
      "sizes": "180x180",
      "type": "image/png",
      "purpose": "maskable any"
    }
  ],
  "prefer_related_applications": false
}


//=================================================
// FILE: /news.html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Новости — Витрина Разбита</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0b0e15;
      --panel: #131a26;
      --text: #eaf2ff;
      --muted: #9db7dd;
      --accent: #4daaff;
      --danger: #E80100;
      --border: #23324a;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; padding: 14px;
      background: var(--bg); color: var(--text);
      font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Arial,sans-serif;
    }
    .container { max-width: 760px; margin: 0 auto; }
    h1 { margin: 6px 0 16px; font-size: 22px; }
    .news-list { display: grid; gap: 14px; }
    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,.25);
    }
    .card h2 { margin: 0 0 8px; font-size: 18px; }
    .date { color: var(--muted); font-size: 13px; margin-bottom: 8px; }
    .media { margin: 10px 0; }
    .media iframe, .media img, .media video {
      width: 100%; border: 0; border-radius: 8px; min-height: 220px; background: #0b0e15;
    }
    .card p { margin: 8px 0; line-height: 1.45; }
    .tags { margin-top: 8px; display: flex; gap: 8px; flex-wrap: wrap; }
    .tag { font-size: 12px; color: var(--accent); background: rgba(77,170,255,.12); border: 1px solid rgba(77,170,255,.25); padding: 4px 8px; border-radius: 999px; }
    .error { color: var(--danger); background: rgba(232,1,0,.1); border: 1px solid rgba(232,1,0,.2); padding: 10px; border-radius: 8px; }
    .loading { color: var(--muted); }
    a { color: var(--accent); text-decoration: none; }
    a:hover { color: #fff; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Новости</h1>
    <div id="status" class="loading">Загрузка...</div>
    <div id="news" class="news-list"></div>
  </div>

  <script>
    async function loadNews() {
      const status = document.getElementById('status');
      const listEl = document.getElementById('news');
      try {
        const r = await fetch('./news/news.json', { cache: 'no-cache' });
        if (!r.ok) throw new Error('HTTP ' + r.status);
        const j = await r.json();
        const items = Array.isArray(j.items) ? j.items : [];
        status.style.display = 'none';
        if (!items.length) {
          status.style.display = '';
          status.textContent = 'Пока новостей нет';
          return;
        }
        listEl.innerHTML = items.map(renderCard).join('');
      } catch (e) {
        status.className = 'error';
        status.textContent = 'Не удалось загрузить новости';
      }
    }
    function esc(s) { return String(s || '').replace(/[<>&'"]/g, m => ({'<':'&lt;','>':'&gt;','&':'&amp;',"'":'&#39;','"':'&quot;'}[m])); }
    function renderCard(it) {
      const title = esc(it.title || 'Новость');
      const date = esc(it.date || '');
      const text = esc(it.text || '');
      const tags = Array.isArray(it.tags) ? it.tags : [];
      let media = '';
      if (it.embedUrl) {
        media = `<div class="media"><iframe loading="lazy" src="${esc(it.embedUrl)}" allowfullscreen></iframe></div>`;
      } else if (it.image) {
        media = `<div class="media"><img loading="lazy" src="${esc(it.image)}" alt=""></div>`;
      } else if (it.video) {
        media = `<div class="media"><video controls preload="metadata" src="${esc(it.video)}"></video></div>`;
      }
      return `<article class="card">
        <h2>${title}</h2>
        ${date ? `<div class="date">${date}</div>` : ''}
        ${media}
        ${text ? `<p>${text}</p>` : ''}
        ${tags.length ? `<div class="tags">${tags.map(t=>`<span class="tag">#${esc(t)}</span>`).join('')}</div>` : ''}
      </article>`;
    }
    loadNews();
  </script>
</body>
</html>

//=================================================
// FILE: /service-worker.js
/* service-worker.js — Витрина Разбита
   Стратегии:
   - Навигация (HTML): network-first с таймаутом и fallback из кэша
   - JSON (config/index/news): network-first с fallback
   - Изображения: cache-first
   - Аудио: stale-while-revalidate (без кеша для Range-запросов)
   - Скрипты/стили/шрифты: cache-first
   Офлайн-пакеты: через сообщения OFFLINE_CACHE_ADD / OFFLINE_CACHE_CLEAR_CURRENT с прогрессом.
*/

const SW_VERSION = '8.0.3';
const CORE_CACHE = `core-${SW_VERSION}`;
const RUNTIME_CACHE = `runtime-${SW_VERSION}`;
const MEDIA_CACHE = 'media'; // постоянное имя для сохранения кэша между версиями
const OFFLINE_CACHE = `offline-${SW_VERSION}`; // базовый (для линтера/совместимости)
const META_CACHE = `meta-${SW_VERSION}`;
// Конфиг по умолчанию (переопределяется через CONFIG_UPDATE из custom.json)
const DEFAULT_SW_CONFIG = {
  mediaMaxCacheMB: 150,
  nonRangeMaxStoreMB: 25,
  nonRangeMaxStoreMBSlow: 10,
  allowUnknownSize: false,
  revalidateDays: 7 // через столько дней делать HEAD‑перевалидацию
};

function metaKey(name) {
  try {
    return new Request(new URL(`__meta__/${String(name)}`, self.registration.scope));
  } catch {
    return new Request(`__meta__/${String(name)}`);
  }
}

const CORE_ASSETS = [
  './',
  './index.html',
  './news.html',
  './news/news.json',
  './manifest.json',
  './img/logo.png',
  './img/star.png',
  './img/star2.png',
  './icons/favicon-16.png',
  './icons/favicon-32.png',
  './icons/apple-touch-icon.png'
];

self.addEventListener('install', (event) => {
  event.waitUntil((async () => {
    const cache = await caches.open(CORE_CACHE);
    try {
      await cache.addAll(CORE_ASSETS.map(url => new Request(url, { cache: 'reload' })));
    } catch (e) {
      console.warn('SW install: some core assets failed to cache', e);
    }
    await self.skipWaiting();
  })());
});

self.addEventListener('activate', (event) => {
  event.waitUntil((async () => {
    const keys = await caches.keys();
    await Promise.all(keys.map(async (k) => {
      // Сохраняем постоянный MEDIA_CACHE и любые старые media-* (мягкая миграция),
      // остальное — по белому списку.
      if (
        k === CORE_CACHE || k === RUNTIME_CACHE || k === MEDIA_CACHE ||
        k === OFFLINE_CACHE || k === META_CACHE || k.startsWith('media-')
      ) return;
      await caches.delete(k);
    }));
    await self.clients.claim();
    try { await postToAllClients({ type: 'SW_VERSION', version: SW_VERSION }); } catch {}
  })());
});

// Утилита: запрос с таймаутом
async function fetchWithTimeout(req, { timeout = 5000 } = {}) {
  const ctrl = new AbortController();
  const id = setTimeout(() => ctrl.abort(), timeout);
  try {
    const res = await fetch(req, { signal: ctrl.signal });
    return res;
  } finally {
    clearTimeout(id);
  }
}

function isJSONRequest(request) {
  const url = new URL(request.url);
  return url.pathname.endsWith('.json') || request.headers.get('accept')?.includes('application/json');
}
function isNavigationRequest(request) {
  return request.mode === 'navigate' || (request.destination === '' && request.method === 'GET');
}
function isImageRequest(request) {
  return request.destination === 'image';
}
function isAudioRequest(request) {
  return request.destination === 'audio' || request.destination === 'media';
}
function isStaticAsset(request) {
  const d = request.destination;
  return d === 'script' || d === 'style' || d === 'font' || d === 'worker';
}

/** Разбор заголовка Range: bytes=start-end */
function parseRangeHeader(range, totalLength) {
  const m = /^bytes=(\d*)-(\d*)$/.exec(String(range || ''));
  if (!m) return null;
  let start = m[1] === '' ? 0 : parseInt(m[1], 10);
  let end = m[2] === '' ? (totalLength - 1) : parseInt(m[2], 10);
  if (Number.isNaN(start)) start = 0;
  if (Number.isNaN(end)) end = totalLength - 1;
  start = Math.max(0, start);
  end = Math.min(totalLength - 1, end);
  if (end < start) return null;
  return { start, end };
}

/** 206 Partial Content из кэша (MEDIA/ОFFLINE), либо сетью как fallback */
async function serveRangeFromCacheOrNetwork(request) {
  const url = request.url;
  const rangeHeader = request.headers.get('range');

  // Для фоновых запросов увеличиваем таймаут
  const clients = await self.clients.matchAll({ includeUncontrolled: true, type: 'window' }).catch(() => []);
  const isBackground = request.headers.get('purpose') === 'prefetch' ||
                       (request.referrer && request.referrer.includes('background')) ||
                       clients.length === 0;

  // Пробуем любой кэш (вкл. старые media-*)
  let res = await caches.match(url);
  if (res && (res.status === 206 || res.type === 'opaque')) {
    res = null; // нужен только 200-full
  }

  if (!res) {
    try {
      const timeout = isBackground ? 30000 : 10000;
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeout);
      const net = await fetch(request, { signal: controller.signal, keepalive: true });
      clearTimeout(id);
      // 206 не кэшируем, 200 можно положить (через non-Range путь)
      return net;
    } catch {
      return new Response('', { status: 404 });
    }
  }

  // Есть полный буфер — собираем 206 Partial Content
  await touchMediaItem(url).catch(()=>{});
  const buf = await res.arrayBuffer();
  const total = buf.byteLength;
  const range = parseRangeHeader(rangeHeader, total);
  if (!range) {
    return new Response('', { status: 416, headers: { 'Content-Range': `bytes */${total}` } });
  }
  const { start, end } = range;
  const chunk = buf.slice(start, end + 1);
  const contentType = res.headers.get('content-type') || 'audio/mpeg';

  const headers = new Headers();
  headers.set('Content-Type', contentType);
  headers.set('Content-Length', String(chunk.byteLength));
  headers.set('Accept-Ranges', 'bytes');
  headers.set('Content-Range', `bytes ${start}-${end}/${total}`);
  headers.set('Cache-Control', 'public, max-age=31536000');
  return new Response(chunk, { status: 206, headers });
}

self.addEventListener('fetch', (event) => {
  const { request } = event;

  // Не вмешиваемся в другие методы кроме GET
  if (request.method !== 'GET') return;

  // Особый случай: Range-запросы для аудио — пробуем 206 из кэша, иначе сеть
    if (isAudioRequest(request) && request.headers.has('range')) {
      event.respondWith(serveRangeFromCacheOrNetwork(request));
      return;
    }

  // Навигация: network-first с таймаутом
  if (isNavigationRequest(request)) {
    event.respondWith((async () => {
      const cache = await caches.open(CORE_CACHE);
      try {
        const netRes = await fetchWithTimeout(request, { timeout: 6000 });
        if (netRes && netRes.ok) {
          cache.put(request, netRes.clone()).catch(() => {});
          return netRes;
        }
        const cached = await cache.match(request);
        if (cached) return cached;
        // fallback на index.html
        const index = await cache.match('./index.html');
        if (index) return index;
        return netRes; // как есть (даже если не ok)
      } catch {
        const cached = await cache.match(request) || await cache.match('./index.html');
        if (cached) return cached;
        return new Response('Offline', { status: 503, statusText: 'Offline' });
      }
    })());
    return;
  }

  // Страницы/данные «Новости»: cache-first с строгой MIME-проверкой
  if (request.url.endsWith('/news.html') || request.url.includes('/news/news.json')) {
    event.respondWith((async () => {
      const cache = await caches.open(RUNTIME_CACHE);
      const cached = await cache.match(request);
      if (cached) return cached;
      try {
        const netRes = await fetch(request);
        if (netRes) {
          const ct = (netRes.headers.get('content-type') || '').toLowerCase();
          const isNewsHtml = request.url.endsWith('/news.html');
          const isNewsJson = request.url.includes('/news/news.json');
          const okForCache =
            (isNewsHtml && ct.includes('text/html')) ||
            (isNewsJson && ct.includes('application/json'));
          if ((netRes.ok || netRes.type === 'opaque') && okForCache) {
            cache.put(request, netRes.clone()).catch(() => {});
          }
        }
        return netRes;
      } catch {
        return (await cache.match(request)) || new Response('', { status: 404 });
      }
    })());
    return;
  }

  // JSON: network-first с fallback
  if (isJSONRequest(request)) {
    event.respondWith((async () => {
      const cache = await caches.open(RUNTIME_CACHE);
      try {
        const netRes = await fetchWithTimeout(request, { timeout: 6000 });
        if (netRes) {
          // Строгая проверка MIME: кэшируем только application/json (или .json)
          const ct = (netRes.headers.get('content-type') || '').toLowerCase();
          const isJsonMime = ct.includes('application/json');
          const isJsonPath = new URL(request.url).pathname.endsWith('.json');
          if ((netRes.ok || netRes.type === 'opaque') && (isJsonMime || isJsonPath)) {
            cache.put(request, netRes.clone()).catch(() => {});
          }
          return netRes;
        }
        const cached = await cache.match(request);
        if (cached) return cached;
        return new Response('Offline JSON', { status: 503 });
      } catch {
        const cached = await cache.match(request);
        if (cached) return cached;
        return new Response('Offline JSON', { status: 503 });
      }
    })());
    return;
  }

  // Изображения: cache-first
  if (isImageRequest(request)) {
    event.respondWith((async () => {
      const cache = await caches.open(MEDIA_CACHE);
      const cached = await cache.match(request);
      if (cached) return cached;
      try {
        const netRes = await fetch(request);
        if (netRes) {
          if (netRes.type === 'opaque') {
            // допускаем opaque-ответы (CDN и т.п.)
            try { cache.put(request, netRes.clone()); } catch {}
          } else if (netRes.ok) {
            const ct = (netRes.headers.get('content-type') || '').toLowerCase();
            if (!ct || ct.startsWith('image/')) {
              try { cache.put(request, netRes.clone()); } catch {}
            }
          }
        }
        return netRes;
      } catch {
        return cached || new Response('', { status: 404 });
      }
    })());
    return;
  }

  // Аудио: stale-while-revalidate (кэшируем ТОЛЬКО 200 full по лимитам; LRU; редкая HEAD‑ревалидация)
  if (isAudioRequest(request)) {
    event.respondWith((async () => {
      const url = request.url;
      // Любой кэш (учтём возможные старые media-*)
      const cached = await caches.match(url);

      if (!request.headers.has('range')) {
        // Фоновая ревалидация (HEAD) для кэшированного
        if (cached) { maybeHeadRevalidate(url).catch(()=>{}); }
        // Параллельно — попытка перевалидировать через GET и положить в persistent media
        (async () => {
          try {
            const netRes = await fetch(request, { keepalive: true });
            if (netRes && netRes.ok && netRes.status === 200 && await shouldCacheNonRangeAudio(netRes)) {
              const cache = await caches.open(MEDIA_CACHE);
              await cache.put(url, netRes.clone());
              const size = bytesFromHeader(netRes) || 0;
              await upsertMediaItem(url, {
                size,
                etag: netRes.headers.get('etag'),
                lastModified: netRes.headers.get('last-modified')
              });
            }
          } catch {}
        })();
      }

      // Отдаём кэш, если есть
      if (cached) {
        touchMediaItem(url).catch(()=>{});
        return cached;
      }

      // Иначе — сеть
      try {
        const netRes = await fetch(request);
        // Положим только 200 full по лимитам
        if (!request.headers.has('range') && netRes && netRes.ok && netRes.status === 200 && await shouldCacheNonRangeAudio(netRes)) {
          const cache = await caches.open(MEDIA_CACHE);
          await cache.put(url, netRes.clone());
          const size = bytesFromHeader(netRes) || 0;
          await upsertMediaItem(url, {
            size,
            etag: netRes.headers.get('etag'),
            lastModified: netRes.headers.get('last-modified')
          });
        }
        return netRes;
      } catch {
        return new Response('', { status: 404 });
      }
    })());
    return;
  }

  // Скрипты/стили/шрифты: cache-first
  if (isStaticAsset(request)) {
    event.respondWith((async () => {
      const cache = await caches.open(RUNTIME_CACHE);
      const cached = await cache.match(request);
      if (cached) return cached;
      try {
        const netRes = await fetch(request);
        if (netRes && netRes.ok) {
          cache.put(request, netRes.clone()).catch(() => {});
        }
        return netRes;
      } catch {
        return cached || new Response('', { status: 404 });
      }
    })());
    return;
  }

  // По умолчанию — просто прокси в сеть
  event.respondWith(fetch(request));
});

// ===== Сообщения от клиента (офлайн кэш пакетами и состояние) =====

async function postToAllClients(msg) {
  const clientsList = await self.clients.matchAll({ includeUncontrolled: true, type: 'window' });
  for (const c of clientsList) c.postMessage(msg);
}

async function readOfflineList() {
  const cache = await caches.open(META_CACHE);
  const key = metaKey('offline-list');
  const res = await cache.match(key);
  if (!res) return [];
  try {
    const json = await res.json();
    return Array.isArray(json) ? json : [];
  } catch { return []; }
}
async function writeOfflineList(list) {
  const cache = await caches.open(META_CACHE);
  const key = metaKey('offline-list');
  await cache.put(key, new Response(JSON.stringify(Array.from(new Set(list))), {
    headers: { 'content-type': 'application/json' }
  }));
}

// Профиль офлайн-кэша (например, 'favorites-webp')
async function writeOfflineProfile(profile) {
  const cache = await caches.open(META_CACHE);
  await cache.put(metaKey('offline-profile'), new Response(JSON.stringify({ profile: String(profile || 'default') }), {
    headers: { 'content-type': 'application/json' }
  }));
}
async function readOfflineProfile() {
  const cache = await caches.open(META_CACHE);
  const res = await cache.match(metaKey('offline-profile'));
  if (!res) return 'default';
  try { const j = await res.json(); return (j && j.profile) ? String(j.profile) : 'default'; } catch { return 'default'; }
}
async function getOfflineCacheName() {
  const prof = await readOfflineProfile().catch(()=> 'default');
  return `offline-${SW_VERSION}-${prof}`;
}

// Храним «последний запрошенный офлайн-список» для Background Sync
async function writeLastRequestedOffline(list) {
  const cache = await caches.open(META_CACHE);
  const key = metaKey('last-requested-offline');
  await cache.put(key, new Response(JSON.stringify(Array.from(new Set(list))), {
    headers: { 'content-type': 'application/json' }
  }));
}
async function readLastRequestedOffline() {
  const cache = await caches.open(META_CACHE);
  const key = metaKey('last-requested-offline');
  const res = await cache.match(key);
  if (!res) return [];
  try { const j = await res.json(); return Array.isArray(j) ? j : []; } catch { return []; }
}
// ----- SW-config (из custom.json через CONFIG_UPDATE) -----
async function writeSwConfig(cfg) {
  const cache = await caches.open(META_CACHE);
  await cache.put(metaKey('sw-config'), new Response(JSON.stringify(cfg || {}), {
    headers: { 'content-type': 'application/json' }
  }));
}
async function readSwConfig() {
  try {
    const cache = await caches.open(META_CACHE);
    const res = await cache.match(metaKey('sw-config'));
    if (!res) return { ...DEFAULT_SW_CONFIG };
    const j = await res.json().catch(()=>null);
    const base = { ...DEFAULT_SW_CONFIG };
    if (j && j.sw && typeof j.sw === 'object') {
      const sw = j.sw;
      base.mediaMaxCacheMB = Number.isFinite(sw.mediaMaxCacheMB) ? sw.mediaMaxCacheMB : base.mediaMaxCacheMB;
      base.nonRangeMaxStoreMB = Number.isFinite(sw.nonRangeMaxStoreMB) ? sw.nonRangeMaxStoreMB : base.nonRangeMaxStoreMB;
      base.nonRangeMaxStoreMBSlow = Number.isFinite(sw.nonRangeMaxStoreMBSlow) ? sw.nonRangeMaxStoreMBSlow : base.nonRangeMaxStoreMBSlow;
      base.allowUnknownSize = typeof sw.allowUnknownSize === 'boolean' ? sw.allowUnknownSize : base.allowUnknownSize;
      base.revalidateDays = Number.isFinite(sw.revalidateDays) ? sw.revalidateDays : base.revalidateDays;
    }
    return base;
  } catch {
    return { ...DEFAULT_SW_CONFIG };
  }
}
// --- NET_STATE + лимиты для non-Range аудио ---
async function writeNetState(state) {
  try {
    const cache = await caches.open(META_CACHE);
    await cache.put(metaKey('net-state'), new Response(JSON.stringify(state || {}), {
      headers: { 'content-type': 'application/json' }
    }));
  } catch {}
}
async function readNetState() {
  try {
    const cache = await caches.open(META_CACHE);
    const res = await cache.match(metaKey('net-state'));
    if (!res) return { saveData: false, downlink: null, effectiveType: null };
    const j = await res.json().catch(()=>null);
    return j && typeof j === 'object' ? j : { saveData: false, downlink: null, effectiveType: null };
  } catch {
    return { saveData: false, downlink: null, effectiveType: null };
  }
}
function bytesFromHeader(res) {
  const h = res && res.headers ? res.headers.get('content-length') : null;
  if (!h) return null;
  const n = parseInt(h, 10);
  return Number.isFinite(n) && n >= 0 ? n : null;
}
async function shouldCacheNonRangeAudio(response) {
  if (!response || !response.ok || response.status !== 200 || response.type === 'opaque') return false;
  // Строже по MIME: если Content-Type задан и это не audio/* — не кэшируем
  const ct = response.headers.get('content-type') || '';
  if (ct && !/^audio\//i.test(ct)) return false;

  const ns = await readNetState();
  const cfg = await readSwConfig();
  const slow = !!ns.saveData || (typeof ns.downlink === 'number' && ns.downlink > 0 && ns.downlink <= 1.3) || (ns.effectiveType && /(^|-)2g$/.test(ns.effectiveType));
  const limitMB = slow ? cfg.nonRangeMaxStoreMBSlow : cfg.nonRangeMaxStoreMB;
  const limitB = limitMB * 1024 * 1024;
  const size = bytesFromHeader(response);
  if (size == null) return !!cfg.allowUnknownSize;
  return size <= limitB;
}

// ----- media-map (LRU) -----
async function readMediaMap() {
  const cache = await caches.open(META_CACHE);
  const res = await cache.match(metaKey('media-map'));
  if (!res) return { totalSize: 0, items: {} };
  try { const j = await res.json(); return (j && typeof j === 'object') ? j : { totalSize: 0, items: {} }; }
  catch { return { totalSize: 0, items: {} }; }
}
async function writeMediaMap(map) {
  const cache = await caches.open(META_CACHE);
  await cache.put(metaKey('media-map'), new Response(JSON.stringify(map), { headers: { 'content-type': 'application/json' } }));
}
async function touchMediaItem(url) {
  try {
    const map = await readMediaMap();
    if (map.items[url]) {
      map.items[url].lastAccess = Date.now();
      await writeMediaMap(map);
    }
  } catch {}
}
async function upsertMediaItem(url, meta) {
  const map = await readMediaMap();
  const prev = map.items[url];
  const size = Number.isFinite(meta.size) ? meta.size : 0;
  if (!prev) {
    map.items[url] = {
      size,
      etag: meta.etag || null,
      lastModified: meta.lastModified || null,
      lastAccess: Date.now(),
      revalidatedAt: meta.revalidatedAt || 0
    };
    map.totalSize += size;
  } else {
    const delta = size - (prev.size || 0);
    map.totalSize += delta;
    prev.size = size;
    prev.etag = meta.etag || prev.etag || null;
    prev.lastModified = meta.lastModified || prev.lastModified || null;
    prev.lastAccess = Date.now();
    if (meta.revalidatedAt) prev.revalidatedAt = meta.revalidatedAt;
  }
  await writeMediaMap(map);
  await ensureMediaBudget(map);
}
async function ensureMediaBudget(mapMaybe) {
  const map = mapMaybe || await readMediaMap();
  const cfg = await readSwConfig();
  const maxBytes = (cfg.mediaMaxCacheMB || 150) * 1024 * 1024;
  if (map.totalSize <= maxBytes) return;
  const mediaCache = await caches.open(MEDIA_CACHE);
  const items = Object.entries(map.items);
  // Сортируем по lastAccess (старые — первыми)
  items.sort((a, b) => (a[1].lastAccess || 0) - (b[1].lastAccess || 0));
  for (const [url, meta] of items) {
    try { await mediaCache.delete(url); } catch {}
    map.totalSize -= meta.size || 0;
    delete map.items[url];
    if (map.totalSize <= maxBytes) break;
  }
  await writeMediaMap(map);
}
async function maybeHeadRevalidate(url) {
  try {
    const cfg = await readSwConfig();
    const map = await readMediaMap();
    const meta = map.items[url];
    if (!meta) return;
    const days = Math.max(1, cfg.revalidateDays || 7);
    const now = Date.now();
    const due = !meta.revalidatedAt || (now - meta.revalidatedAt) > days * 24 * 60 * 60 * 1000;
    if (!due) return;

    const headReq = new Request(url, { method: 'HEAD', cache: 'no-cache' });
    const head = await fetch(headReq).catch(()=>null);
    if (!head || !(head.ok || head.status === 304)) {
      // отметим попытку, чтобы не ддосить
      meta.revalidatedAt = now;
      await writeMediaMap(map);
      return;
    }
    const etag = head.headers.get('etag');
    const lm = head.headers.get('last-modified');
    const changed = (etag && etag !== meta.etag) || (lm && lm !== meta.lastModified);
    // Обновим отметку regardless
    meta.revalidatedAt = now;
    await writeMediaMap(map);

    if (!changed) return;

    // Забираем новый full‑200 и кладём (с лимитами)
    const getRes = await fetch(new Request(url, { cache: 'reload' })).catch(()=>null);
    if (getRes && getRes.ok && getRes.status === 200 && await shouldCacheNonRangeAudio(getRes)) {
      const cache = await caches.open(MEDIA_CACHE);
      await cache.put(url, getRes.clone());
      const size = bytesFromHeader(getRes) || 0;
      await upsertMediaItem(url, {
        size,
        etag: getRes.headers.get('etag'),
        lastModified: getRes.headers.get('last-modified'),
        revalidatedAt: now
      });
    }
  } catch {}
}

self.addEventListener('message', (event) => {
  const data = event.data || {};
  if (data.type === 'OFFLINE_CACHE_ADD') {
    const resources = Array.isArray(data.resources) ? data.resources : [];
    event.waitUntil((async () => {
      await writeLastRequestedOffline(resources);
      await offlineAddResources(resources);
    })());
  }
  if (data.type === 'OFFLINE_CACHE_CLEAR_CURRENT') {
    event.waitUntil(clearCurrentOfflineResources());
  }
  if (data.type === 'REQUEST_OFFLINE_STATE') {
    event.waitUntil((async () => {
      const list = await readOfflineList();
      postToAllClients({ type: 'OFFLINE_STATE', value: list.length > 0 });
    })());
  }
  if (data.type === 'NET_STATE' && data.state) {
    event.waitUntil(writeNetState(data.state));
  }
  if (data.type === 'CONFIG_UPDATE' && data.config) {
    event.waitUntil(writeSwConfig(data.config));
  }
  if (data.type === 'SKIP_WAITING') {
    event.waitUntil(self.skipWaiting());
  }
  if (data.type === 'GET_SW_VERSION') {
    event.waitUntil(postToAllClients({ type: 'SW_VERSION', version: SW_VERSION }));
  }
  if (data.type === 'OFFLINE_SET_PROFILE') {
    event.waitUntil(writeOfflineProfile(data.profile || 'default'));
  }
  if (data.type === 'PREFETCH_AUDIO') {
    const list = Array.isArray(data.urls) ? data.urls : (data.url ? [data.url] : []);
    if (!list.length) return;
    event.waitUntil((async () => {
      for (const u of list) {
        try {
          const req = new Request(u, { cache: 'reload', keepalive: true });
          const res = await fetch(req);
          if (res && res.ok && res.status === 200 && await shouldCacheNonRangeAudio(res)) {
            const cache = await caches.open(MEDIA_CACHE);
            await cache.put(req, res.clone());
            const size = bytesFromHeader(res) || 0;
            await upsertMediaItem(req.url, {
              size,
              etag: res.headers.get('etag'),
              lastModified: res.headers.get('last-modified')
            });
          }
        } catch {}
      }
    })());
  }
  if (data.type === 'GET_SW_INFO') {
    event.waitUntil((async () => {
      try {
        const [profile, cfg, net, mediaMap, offList] = await Promise.all([
          readOfflineProfile().catch(()=>'default'),
          readSwConfig().catch(()=>({})),
          readNetState().catch(()=>({})),
          readMediaMap().catch(()=>({ totalSize: 0, items: {} })),
          readOfflineList().catch(()=>[])
        ]);
        const info = {
          version: SW_VERSION,
          profile,
          config: cfg,
          net,
          media: {
            totalBytes: Number(mediaMap.totalSize || 0),
            items: mediaMap.items ? Object.keys(mediaMap.items).length : 0
          },
          offline: {
            profile,
            count: Array.isArray(offList) ? offList.length : 0
          }
        };
        await postToAllClients({ type: 'SW_INFO', info });
      } catch {
        await postToAllClients({ type: 'SW_INFO', info: { version: SW_VERSION } });
      }
    })());
  }
});

// One-off Background Sync: докачка офлайн-списка при появлении сети
self.addEventListener('sync', (event) => {
  if (event.tag === 'offline-favorites-cache') {
    event.waitUntil((async () => {
      try {
        const pending = await readLastRequestedOffline();
        if (pending && pending.length) {
          await offlineAddResources(pending);
        }
      } catch (e) {
        // пропускаем — sync повторится позже
      }
    })());
  }
});

async function offlineAddResources(resources) {
  if (!resources || !resources.length) {
    await writeOfflineList([]);
    await postToAllClients({ type: 'OFFLINE_DONE' });
    return;
  }
  const cache = await caches.open(await getOfflineCacheName());
  const prev = await readOfflineList();
  const toCache = resources.map(u => {
    try { return new URL(u, self.registration.scope).toString(); } catch { return u; }
  });
  let done = 0;
  const total = toCache.length;
  const errors = [];

  for (const url of toCache) {
    try {
      const isAudio = /\.(mp3|m4a|aac|flac|ogg|wav)(\?|#|$)/i.test(url);

      let res = await fetch(url, { cache: 'no-cache', keepalive: true }).catch(() => null);

      if (isAudio) {
        if (res && res.ok && res.type !== 'opaque') {
          await cache.put(url, res.clone());
        } else {
          errors.push(url);
        }
      } else {
        if (!res || !(res.ok || res.type === 'opaque')) {
          res = await fetch(url, { mode: 'no-cors' }).catch(() => null);
        }
        if (res) {
          await cache.put(url, res.clone());
        } else {
          errors.push(url);
        }
      }

      done++;
      await postToAllClients({ type: 'OFFLINE_PROGRESS', percent: Math.round(done / total * 100) });
    } catch (e) {
      errors.push(url);
      done++;
      await postToAllClients({ type: 'OFFLINE_PROGRESS', percent: Math.round(done / total * 100) });
    }
  }
  await writeOfflineList([...prev, ...toCache]);
  await writeLastRequestedOffline([]);
  if (errors.length) {
    console.warn('OFFLINE_CACHE_ADD errors:', errors);
    await postToAllClients({ type: 'OFFLINE_ERROR', errors });
  }
  await postToAllClients({ type: 'OFFLINE_DONE' });
}

async function clearCurrentOfflineResources() {
  const cache = await caches.open(await getOfflineCacheName());
  const list = await readOfflineList();
  if (list.length) {
    await Promise.allSettled(list.map(u => cache.delete(u)));
  }
  await writeOfflineList([]);
  await postToAllClients({ type: 'OFFLINE_DONE' });
}

//=================================================
// FILE: /performance/rum.js
;(function(){
  // Неболезненная заглушка: чтобы <script src="./performance/rum.js"> не давал 404
  // и не ломал метрики. Если в custom.json появится endpoint — ваш код в index.html
  // вызовет initRUM(...) при наличии совпадающей функции.
  if (typeof window.initRUM !== 'function') {
    window.initRUM = function initRUM() { /* no-op */ };
  }
})();

//=================================================
// FILE: /scripts/app.js
// scripts/app.js
// Главный модуль приложения - инициализация и оркестрация

import { APP_CONFIG } from './core/config.js';

class MusicApp {
  constructor() {
    this.initialized = false;
    this.playerReady = false;
  }

  async init() {
    if (this.initialized) return;
    
    try {
      // Проверка промокода
      await this.checkPromocode();
      
      // Инициализация PlayerCore
      await this.initPlayerCore();
      
      // Инициализация UI
      await this.initUI();
      
      // Загрузка альбомов
      await this.loadAlbums();
      
      // Восстановление состояния
      await this.restoreState();
      
      this.initialized = true;
      console.log('✅ App initialized');
    } catch (error) {
      console.error('❌ App initialization failed:', error);
      window.NotificationSystem?.error('Ошибка инициализации приложения');
    }
  }

  async checkPromocode() {
    const passed = localStorage.getItem('promoPassed') === '1';
    
    if (passed) {
      this.showMain();
      return;
    }

    // Обработчик промокода
    const input = document.getElementById('promo-inp');
    const button = document.getElementById('promo-btn');
    const error = document.getElementById('promo-error');

    const check = () => {
      const value = (input?.value || '').trim();
      if (!value) {
        if (error) error.innerText = 'Введите промокод';
        return;
      }
      
      if (value.toUpperCase() === APP_CONFIG.PROMO_CODE.toUpperCase()) {
        localStorage.setItem('promoPassed', '1');
        this.showMain();
      } else {
        if (error) error.innerText = 'Неверный промокод';
      }
    };

    button?.addEventListener('click', check);
    input?.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') check();
    });
  }

  showMain() {
    document.getElementById('promocode-block')?.classList.add('hidden');
    document.getElementById('main-block')?.classList.remove('hidden');
  }

  async initPlayerCore() {
    // Адаптер загружается автоматически через player-adapter.js
    // Ждём готовности
    return new Promise((resolve) => {
      const check = () => {
        if (window.playerCore) {
          this.playerReady = true;
          resolve();
        } else {
          setTimeout(check, 100);
        }
      };
      check();
    });
  }

  async initUI() {
    // UI модули загружаются через script tags
    // Здесь только финальная инициализация
    
    // Логотипы
    this.applyLogos();
    
    // PWA install button
    this.initPWA();
    
    // Обработчики событий
    this.attachEventListeners();
  }

  applyLogos() {
    const dpr = window.devicePixelRatio || 1;
    const mobile = /Android|webOS|iPhone|iPad|iPod/i.test(navigator.userAgent);
    
    let logoUrl;
    if (mobile) {
      logoUrl = dpr >= 2 ? 'img/mobile/logo@2x.jpg' : 'img/mobile/logo@1x.jpg';
    } else {
      if (dpr >= 3) logoUrl = 'img/desktop/logo@3x.png';
      else if (dpr >= 2) logoUrl = 'img/desktop/logo@2x.png';
      else logoUrl = 'img/desktop/logo@1x.png';
    }

    const logoBottom = document.getElementById('logo-bottom');
    const promoCover = document.getElementById('promo-cover');
    if (logoBottom) logoBottom.src = logoUrl;
    if (promoCover) promoCover.src = logoUrl;
  }

  initPWA() {
    let deferredPrompt;

    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      const btn = document.getElementById('install-pwa-btn');
      if (btn) btn.style.display = '';
    });

    document.getElementById('install-pwa-btn')?.addEventListener('click', async () => {
      if (deferredPrompt) {
        deferredPrompt.prompt();
        deferredPrompt.userChoice.finally(() => {
          const btn = document.getElementById('install-pwa-btn');
          if (btn) btn.style.display = 'none';
          deferredPrompt = null;
        });
      }
    });
  }

  attachEventListeners() {
    // Логотип
    document.getElementById('logo-bottom')?.addEventListener('click', () => {
      const logo = document.getElementById('logo-bottom');
      if (!logo) return;
      logo.style.transition = 'transform .08s ease-out';
      logo.style.transform = 'scale(1.13)';
      setTimeout(() => {
        logo.style.transform = 'scale(1)';
        logo.style.transition = 'transform .1s ease-out';
      }, 120);
    });

    // Обратная связь
    document.getElementById('feedback-link')?.addEventListener('click', () => {
      window.NotificationSystem?.info('Раздел в разработке. Напишите нам в Telegram: @vitrina_razbita');
    });

    // Фильтр избранного
    document.getElementById('filter-favorites-btn')?.addEventListener('click', () => {
      if (typeof window.toggleFavoritesFilter === 'function') {
        window.toggleFavoritesFilter();
      }
    });

    // Скачать альбом
    document.getElementById('download-album-main')?.addEventListener('click', () => {
      window.NotificationSystem?.info('Функция скачивания альбома в разработке');
    });

    // Оффлайн кнопка
    document.getElementById('offline-btn')?.addEventListener('click', () => {
      window.NotificationSystem?.info('Оффлайн режим в разработке');
    });
  }

  async loadAlbums() {
    try {
      const response = await fetch('./albums.json', { cache: 'no-cache' });
      const data = await response.json();
      window.albumsIndex = Array.isArray(data.albums) ? data.albums : [];
    } catch (error) {
      console.warn('Failed to load albums.json, using fallback');
      window.albumsIndex = APP_CONFIG.ALBUMS_FALLBACK.slice();
    }

    if (window.albumsIndex.length > 0) {
      // Инициализация альбомов через albums.js модуль
      if (typeof window.AlbumsManager?.initialize === 'function') {
        await window.AlbumsManager.initialize();
      }
    }
  }

  async restoreState() {
    try {
      // Восстановление режимов
      window.shuffleMode = localStorage.getItem('shuffleMode') === '1';
      window.repeatMode = localStorage.getItem('repeatMode') === '1';
      window.favoritesOnlyMode = localStorage.getItem('favoritesOnlyMode') === '1';
      window.animationEnabled = localStorage.getItem('animationEnabled') === '1';
      
      // Восстановление последнего альбома
      const lastAlbum = localStorage.getItem('currentAlbum');
      if (lastAlbum && typeof window.AlbumsManager?.loadAlbum === 'function') {
        await window.AlbumsManager.loadAlbum(lastAlbum);
      }
    } catch (error) {
      console.warn('Failed to restore state:', error);
    }
  }
}

// Автостарт при загрузке
window.addEventListener('DOMContentLoaded', () => {
  window.musicApp = new MusicApp();
  window.musicApp.init();
});

//=================================================
// FILE: /scripts/app/albums.js


//=================================================
// FILE: /scripts/app/background-audio.js
// scripts/app/background-audio.js
// Фоновые iOS/Android аудио-хелперы + адаптер к PlayerCore для автозапуска на iOS.

(function BackgroundAudioModule() {
  function isIOSUA() {
    try { return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; }
    catch { return false; }
  }

  function initAudioContextForBackground() {
    try {
      window.__audioContext = new (window.AudioContext || window.webkitAudioContext)({
        latencyHint: 'playback',
        sampleRate: 44100
      });
      window.__audioContext.onstatechange = () => {
        if (window.__audioContext.state === 'suspended') {
          window.__audioContext.resume().catch(console.warn);
        }
      };
      const oscillator = window.__audioContext.createOscillator();
      const gainNode = window.__audioContext.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(window.__audioContext.destination);
      gainNode.gain.value = 0.00001;
      oscillator.start(0);
      window.__backgroundOscillator = oscillator;
      window.__backgroundGainNode = gainNode;
      console.log('iOS AudioContext initialized for background playback');
    } catch (e) {
      console.warn('Failed to initialize iOS AudioContext', e);
    }
  }

  function resumeAudioContextIfNeeded() {
    try {
      if (window.__audioContext && window.__audioContext.state === 'suspended') {
        window.__audioContext.resume().catch(console.warn);
      }
    } catch (e) {
      console.warn('Failed to resume audio context', e);
    }
  }

  function initSilentAudioPlayback() {
    if (!isIOSUA()) return;
    try {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      gainNode.gain.value = 0.00001;
      oscillator.start(0);
      window.__silentOscillator = oscillator;
      window.__silentAudioContext = audioContext;
      setTimeout(() => {
        try {
          oscillator.stop();
          audioContext.close().catch(console.warn);
          delete window.__silentOscillator;
          delete window.__silentAudioContext;
        } catch (e) {
          console.warn('Failed to clean silent audio', e);
        }
      }, 2000);
      console.log('Silent audio playback initialized for iOS background mode');
    } catch (e) {
      console.warn('Failed to initialize silent audio playback', e);
    }
  }

  // Глобальные алиасы
  window.initAudioContextForBackground = initAudioContextForBackground;
  window.resumeAudioContextIfNeeded = resumeAudioContextIfNeeded;
  window.initSilentAudioPlayback = initSilentAudioPlayback;

  // Адаптер к PlayerCore: на iOS один раз запускаем initAudioContextForBackground при первом play()
  (function hookPlayerCoreOnce() {
    if (!isIOSUA()) return;
    let hooked = false;
    function bindIfReady() {
      try {
        if (hooked) return;
        const pc = window.playerCore;
        if (!pc || typeof pc.on !== 'function') return;
        if (window.PlayerCoreObserver) {
          window.PlayerCoreObserver.add({
            onPlay: () => {
              if (hooked) return;
              hooked = true;
              try { initAudioContextForBackground(); } catch {}
            }
          });
        } else {
          // Фолбэк (не должен сработать при корректной загрузке bootstrap.js)
          pc.on({
            onPlay: () => {
              if (hooked) return;
              hooked = true;
              try { initAudioContextForBackground(); } catch {}
            }
          });
        }
      } catch {}
    }
    // Пытаемся сразу и при первом user-gesture/ленивой загрузке адаптера
    bindIfReady();
    const id = setInterval(() => { if (hooked) { clearInterval(id); } else { bindIfReady(); } }, 300);
    // Остановим опрос через 10 сек
    setTimeout(() => clearInterval(id), 10000);
  })();

})();

//=================================================
// FILE: /scripts/app/background-events.js
// scripts/app/background-events.js
// Фоновые события: visibilitychange/freeze/resume/pagehide/pageshow/focusout.
// Только безопасные операции: сохранить позицию, обновить UI/MediaSession, НЕ pause/stop.

(function BackgroundEvents() {
  function pc() { return (window.playerCore || null); }
  function isIOS() { try { return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; } catch { return false; } }

  // freeze/resume: сохранить/восстановить позицию (без управления звуком)
  document.addEventListener('freeze', () => {
    try {
      const p = pc();
      if (p && typeof p.getSeek === 'function') {
        window.__savedResumePosition = p.getSeek() || 0;
        localStorage.setItem('freezePosition', String(window.__savedResumePosition));
      } else {
        // legacy пути больше нет — ветка оставлена для совместимости
        localStorage.setItem('freezePosition', String(window.__savedResumePosition || 0));
      }
    } catch {}
  });

  document.addEventListener('resume', () => {
    try {
      const raw = localStorage.getItem('freezePosition');
      localStorage.removeItem('freezePosition');
      if (!raw) return;
      const pos = parseFloat(raw);
      if (!Number.isFinite(pos)) return;

      const TOL = 0.75;
      const p = pc();
      if (p) {
        const cur = Number(p.getSeek?.() || 0);
        if (!Number.isFinite(cur) || cur < (pos - TOL)) p.seek(pos);
      }
      if (typeof window.syncUiFromPlayback === 'function') window.syncUiFromPlayback();
    } catch {}
  });

  // Потеря фокуса при скрытии — только сохранить позицию
  try {
    if ('onfocusout' in document) {
      document.addEventListener('focusout', () => {
        if (document.hidden) {
          try { window.__savedResumePosition = pc()?.getSeek?.() || 0; } catch {}
        }
      });
    }
  } catch {}

  // iOS BFCache: pagehide/pageshow — сохранить/восстановить позицию
  if (isIOS()) {
    window.addEventListener('pagehide', (e) => {
      if (!e.persisted) return;
      try {
        window.__savedResumePosition = pc()?.getSeek?.() || 0;
        localStorage.setItem('iosBackgroundPosition', String(window.__savedResumePosition));
      } catch {}
    });

    window.addEventListener('pageshow', (e) => {
      if (!e.persisted) return;
      try {
        const raw = localStorage.getItem('iosBackgroundPosition');
        localStorage.removeItem('iosBackgroundPosition');
        if (!raw) return;
        const pos = parseFloat(raw);
        if (!Number.isFinite(pos)) return;
        const TOL = 0.75;
        const p = pc();
        if (p) {
          const cur = Number(p.getSeek?.() || 0);
          if (!Number.isFinite(cur) || cur < (pos - TOL)) p.seek(pos);
        }
        if (typeof window.syncUiFromPlayback === 'function') window.syncUiFromPlayback();
      } catch {}
    });
  }

  // visibilitychange: без паузы/стопа — сохраняем позицию, ослабляем/возвращаем UI, обновляем MediaSession
  document.addEventListener('visibilitychange', async () => {
    try {
      const isHidden = document.hidden;
      const p = pc();
      if (isHidden) {
        // Сохраняем только для возможной подстраховки
        window.__wasPlayingBeforeHidden = p ? !!p.isPlaying?.() : false;
        window.__savedResumePosition = p ? (p.getSeek?.() || 0) : 0;

        // Облегчаем UI
        if (window.coverAutoplay) { clearInterval(window.coverAutoplay); window.coverAutoplay = null; }
        if (window.animationEnabled) { window.__savedAnimationState = window.animationEnabled; window.applyAnimationState && window.applyAnimationState(false); }
        if (window.bitEnabled) { window.__savedBitState = window.bitEnabled; window.stopLogoPulsation && window.stopLogoPulsation(); }
      } else {
        // Возврат: таймер сна, iOS resume аудиоконтекста (через фоновые хелперы)
        try { window.checkSleepTimer && window.checkSleepTimer(); } catch {}
        try { window.resumeAudioContextIfNeeded && window.resumeAudioContextIfNeeded(); } catch {}

        // Восстановление позиции — только если реально потерялась
        const TOL = 0.75;
        if (window.__wasPlayingBeforeHidden && !window.sleepTimerTarget && p) {
          const cur = Number(p.getSeek?.() || 0);
          const saved = window.__savedResumePosition;
          const needRestore = (typeof saved === 'number' && !isNaN(saved)) &&
                              (!Number.isFinite(cur) || cur < (saved - TOL));
          if (needRestore) { try { p.seek(saved); } catch {} }
        }

        // UI синхронизация
        try { window.syncUiFromPlayback && window.syncUiFromPlayback(); } catch {}
        if (window.__savedAnimationState != null && window.applyAnimationState) {
          window.applyAnimationState(window.__savedAnimationState); window.__savedAnimationState = null;
        }
        if (window.__savedBitState && window.startLogoPulsation) {
          try { window.initAudioContext && window.initAudioContext(); } catch {}
          window.startLogoPulsation(); window.__savedBitState = null;
        }
        if (!window.coverAutoplay && Array.isArray(window.coverGalleryArr) && window.coverGalleryArr.length > 1) {
          window.startCoverAutoPlay && window.startCoverAutoPlay();
        }
        window.__savedResumePosition = null;
      }

      // Обновляем Media Session позицию
      try { window.updateMediaSessionPosition && window.updateMediaSessionPosition(); } catch {}
    } catch {}
  });

})();

//=================================================
// FILE: /scripts/app/downloads.js


//=================================================
// FILE: /scripts/app/navigation.js


//=================================================
// FILE: /scripts/app/player-controls.js
// scripts/app/player-controls.js
// Слой базовых контролов плеера (Play/Pause/Stop/Prev/Next/Seek/Volume/Mute).
// Контракт: приоритет PlayerCore, мягкий фолбэк на legacy <audio>.
// Важно: воспроизведение не прерывается никакими действиями, кроме Пауза/Стоп/Таймер сна.

(function PlayerControlsModule(){
  function pc() { return (window.__useNewPlayerCore && window.playerCore) ? window.playerCore : null; }
  function audioEl() {
    return (window.getCurrentAudio && window.getCurrentAudio()) || document.getElementById('audio') || null;
  }

  // Безопасная инициализация playerCore по требованию
  async function ensureCoreReadyOrFallback() {
    const forceNoLegacy = (window.__useNewPlayerCore && (localStorage.getItem('noLegacyAudio') === '1'));
    if (!window.__useNewPlayerCore) return true;
    if (pc()) return true;
    try {
      const ready = await (window.ensurePlayerCoreReady ? window.ensurePlayerCoreReady({ timeoutMs: 1800 }) : Promise.resolve(false));
      if (!ready && forceNoLegacy) {
        window.NotificationSystem && window.NotificationSystem.info('Инициализация плеера...');
        return false;
      }
      return ready;
    } catch { return false; }
  }

  function applyPostUiSync() {
    try { window.applyMiniModeUI && window.applyMiniModeUI(); } catch {}
    try { window.updateMiniNowHeader && window.updateMiniNowHeader(); } catch {}
    try { window.updateNextUpLabel && window.updateNextUpLabel(); } catch {}
    try { window.updatePlayPauseIcon && window.updatePlayPauseIcon(); } catch {}
  }

  // ====== Play/Pause/Prev/Next/Stop ======
  async function togglePlayPause() {
    const ready = await ensureCoreReadyOrFallback();

    // Приоритет — PlayerCore
    if (window.__useNewPlayerCore && pc()) {
      try { window.ensurePlayerCoreUiBindings && window.ensurePlayerCoreUiBindings(); } catch {}

      try {
        if (typeof pc().isPlaying === 'function' && pc().isPlaying()) {
          pc().pause();
          setTimeout(() => { try { window.updatePlayPauseIcon && window.updatePlayPauseIcon(); } catch {} }, 0);
          return;
        }
      } catch {}

      // Инициализация плейлиста при первом старте
      try {
        const hasLoaded = (typeof pc().getDuration === 'function') && ((pc().getDuration() || 0) > 0);
        if (!hasLoaded) {
          // Спец‑ветка для «ИЗБРАННОГО»: никогда не инициализируем альбомом
          if ((window.viewMode === 'favorites') || (window.playingAlbumKey === window.SPECIAL_FAVORITES_KEY)) {
            if (typeof window.ensureFavoritesPlayback === 'function') {
              // Запустим с первого активного избранного
              await window.ensureFavoritesPlayback(0);
              return;
            }
          }
          // Обычная инициализация (альбом/конфиг)
          if (typeof window.__buildPlayerCorePayload === 'function') {
            const payload = window.__buildPlayerCorePayload();
            if (payload) {
              pc().setPlaylist(payload.tracks, payload.index, payload.meta);
              try { pc().setShuffle(!!window.shuffleMode); } catch {}
              try { pc().setRepeat(!!window.repeatMode); } catch {}
              try {
                const likedIdx = (window.playingAlbumKey && window.playingAlbumKey !== window.SPECIAL_FAVORITES_KEY)
                  ? (window.getLikedForAlbum ? window.getLikedForAlbum(window.playingAlbumKey) : [])
                  : [];
                // В альбомном режиме можно включить фильтр ⭐, в «ИЗБРАННОМ» — нет (см. ensureFavoritesPlayback/playFromPlaybackAlbum)
                pc().setFavoritesOnly(!!window.favoritesOnlyMode, likedIdx);
              } catch {}
            }
          }
        }
      } catch {}

      try { pc().play(); } catch {}
      setTimeout(() => { try { window.updatePlayPauseIcon && window.updatePlayPauseIcon(); } catch {} }, 0);
      return;
    }

    // Фолбэк — legacy <audio>
    if (!ready && window.__useNewPlayerCore) return;
    try {
      const a = audioEl();
      if (!a) return;
      if (a.paused) { a.play().catch(()=>{}); } else { a.pause(); }
    } catch {}
  }

  async function previousTrack() {
    // Если новое ядро включено, но ещё не готово — не откатываемся на legacy.
    if (window.__useNewPlayerCore && !pc()) {
      const ready = await (typeof ensureCoreReadyOrFallback === 'function' ? ensureCoreReadyOrFallback() : Promise.resolve(false));
      if (!ready) {
        window.NotificationSystem && window.NotificationSystem.info('Инициализация плеера...');
        return;
      }
    }

    if (window.__useNewPlayerCore && pc()) {
      try { window.ensurePlayerCoreUiBindings && window.ensurePlayerCoreUiBindings(); } catch {}
      try {
        const hasLoaded = (typeof pc().getDuration === 'function') && ((pc().getDuration() || 0) > 0);
        if (!hasLoaded && typeof window.__buildPlayerCorePayload === 'function') {
          const payload = window.__buildPlayerCorePayload();
          if (payload) {
            pc().setPlaylist(payload.tracks, payload.index, payload.meta);
            try { pc().setShuffle(!!window.shuffleMode); } catch {}
            try { pc().setRepeat(!!window.repeatMode); } catch {}
            try { pc().setFavoritesOnly(!!window.favoritesOnlyMode, []); } catch {}
          }
        }
      } catch {}
      try {
        if (window.repeatMode) { pc().seek && pc().seek(0); pc().play && pc().play(); }
        else { pc().prev && pc().prev(); }
      } catch {}
      setTimeout(() => {
        try {
          const idx = (typeof pc().getIndex === 'function') ? pc().getIndex() : 0;
          window.__syncUiToPlayerCoreIndex && window.__syncUiToPlayerCoreIndex(idx);
        } catch {}
      }, 0);
      return;
    }

    // Фолбэк (legacy): рассчитать предыдущий индекс в контексте «игры»
    try {
      // Если ещё ничего не играет — запустим первый трек текущего альбома
      if (!Array.isArray(window.playingTracks) || window.playingTracks.length === 0) {
        if (typeof window.showTrack === 'function') window.showTrack(0, true);
        return;
      }
      const len = window.playingTracks.length;
      // База доступных с учётом режима «только ⭐»
      const available = (typeof window.getAvailableTracksForAlbum === 'function')
        ? window.getAvailableTracksForAlbum(window.playingAlbumKey, len)
        : Array.from({ length: len }, (_, i) => i);

      if (!available || available.length === 0) return;

      let target = -1;
      if (window.shuffleMode && Array.isArray(window.playingShuffledPlaylist) && window.playingShuffledPlaylist.length) {
        const arr = window.playingShuffledPlaylist.slice();
        const pos = arr.indexOf(window.playingTrack);
        const prevPos = (pos - 1 + arr.length) % arr.length;
        target = arr[prevPos];
      } else if (window.favoritesOnlyMode) {
        const pos = available.indexOf(window.playingTrack);
        target = available[(pos - 1 + available.length) % available.length];
      } else {
        target = (window.playingTrack - 1 + len) % len;
      }

      if (Number.isFinite(target) && target >= 0) {
        if (typeof window.playFromPlaybackAlbum === 'function') window.playFromPlaybackAlbum(target, true);
        else if (typeof window.showTrack === 'function') window.showTrack(target, true);
      }
    } catch {}
  }

  async function nextTrack() {
    // Если новое ядро включено, но ещё не готово — не откатываемся на legacy.
    if (window.__useNewPlayerCore && !pc()) {
      const ready = await (typeof ensureCoreReadyOrFallback === 'function' ? ensureCoreReadyOrFallback() : Promise.resolve(false));
      if (!ready) {
        window.NotificationSystem && window.NotificationSystem.info('Инициализация плеера...');
        return;
      }
    }

    if (window.__useNewPlayerCore && pc()) {
      try { window.ensurePlayerCoreUiBindings && window.ensurePlayerCoreUiBindings(); } catch {}
      try {
        const hasLoaded = (typeof pc().getDuration === 'function') && ((pc().getDuration() || 0) > 0);
        if (!hasLoaded && typeof window.__buildPlayerCorePayload === 'function') {
          const payload = window.__buildPlayerCorePayload();
          if (payload) {
            pc().setPlaylist(payload.tracks, payload.index, payload.meta);
            try { pc().setShuffle(!!window.shuffleMode); } catch {}
            try { pc().setRepeat(!!window.repeatMode); } catch {}
            try { pc().setFavoritesOnly(!!window.favoritesOnlyMode, []); } catch {}
          }
        }
      } catch {}
      try {
        if (window.repeatMode) { pc().seek && pc().seek(0); pc().play && pc().play(); }
        else { pc().next && pc().next(); }
      } catch {}
      setTimeout(() => {
        try {
          const idx = (typeof pc().getIndex === 'function') ? pc().getIndex() : 0;
          window.__syncUiToPlayerCoreIndex && window.__syncUiToPlayerCoreIndex(idx);
        } catch {}
      }, 0);
      return;
    }

    // Фолбэк (legacy): используем текущую функцию вычисления следующего индекса
    try {
      if (typeof window.computeNextIndexPlayback === 'function') {
        const idx = window.computeNextIndexPlayback();
        if (Number.isFinite(idx) && idx >= 0) {
          if (typeof window.playFromPlaybackAlbum === 'function') window.playFromPlaybackAlbum(idx, true);
          else if (typeof window.showTrack === 'function') window.showTrack(idx, true);
        }
      }
    } catch {}
  }

  function stopPlayback() {
    if (window.__useNewPlayerCore && pc()) {
      try { pc().stop && pc().stop(); } catch {}
      // При стопе гарантированно отпускаем locks и обновляем Media Session/иконку
      try { window.updatePlayPauseIcon && window.updatePlayPauseIcon(); } catch {}
      try { window.updateMediaSessionPosition && window.updateMediaSessionPosition(); } catch {}
      try { window.setPlaybackLocks && window.setPlaybackLocks(false); } catch {}
      return;
    }
    try {
      const a = audioEl();
      if (a) { a.pause(); a.currentTime = 0; }
      applyPostUiSync();
      // Фолбэк: привести Media Session и локи в консистентное состояние
      try { window.updateMediaSessionPosition && window.updateMediaSessionPosition(); } catch {}
      try { window.setPlaybackLocks && window.setPlaybackLocks(false); } catch {}
    } catch {}
  }

  // ====== Seek/Volume/Mute ======
  function seekFromEvent(e) {
    try {
      const bar = e?.currentTarget || document.getElementById('player-progress-bar');
      if (!bar || typeof bar.getBoundingClientRect !== 'function') return;
      const rect = bar.getBoundingClientRect();
      const clientX = e?.clientX ?? (e?.touches && e.touches[0] && e.touches[0].clientX);
      if (typeof clientX !== 'number') return;
      const percent = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));

      if (window.__useNewPlayerCore && pc() && typeof pc().getDuration === 'function') {
        const dur = Number(pc().getDuration() || 0);
        if (dur > 0) { try { pc().seek(dur * percent); } catch {} }
        return;
      }
      const a = audioEl();
      if (a && isFinite(a.duration) && a.duration > 0) {
        a.currentTime = a.duration * percent;
      }
    } catch {}
  }

  function onVolumeInput(e) {
    const raw = e && e.target ? e.target.value : 100;
    const vol = Math.max(0, Math.min(1, Number(raw) / 100));

    if (window.__useNewPlayerCore && pc() && typeof pc().setVolume === 'function') {
      try { pc().setVolume(vol); } catch {}
    } else {
      try { const a = audioEl(); if (a) a.volume = vol; } catch {}
    }

    try { window.updateVolumeUI && window.updateVolumeUI(vol); } catch {}
    try { localStorage.setItem('playerVolume', String(vol)); } catch {}
  }

  function toggleMute() {
    // Новый плеер
    if (window.__useNewPlayerCore && pc()) {
      try {
        const cur = (typeof pc().getVolume === 'function') ? (pc().getVolume() || 0) : 1;
        if (cur > 0) {
          try { localStorage.setItem('playerVolume', String(cur)); } catch {}
          pc().setVolume(0);
          try { window.updateVolumeUI && window.updateVolumeUI(0); } catch {}
        } else {
          const saved = parseFloat(localStorage.getItem('playerVolume') || '1');
          const vol = Number.isFinite(saved) && saved > 0 ? saved : 1;
          pc().setVolume(vol);
          try { window.updateVolumeUI && window.updateVolumeUI(vol); } catch {}
        }
      } catch {}
      return;
    }

    // Старый плеер
    try {
      const a = audioEl();
      if (!a) return;
      if (a.volume > 0) {
        localStorage.setItem('playerVolume', String(a.volume));
        a.volume = 0;
        try { window.updateVolumeUI && window.updateVolumeUI(0); } catch {}
      } else {
        const saved = parseFloat(localStorage.getItem('playerVolume') || '1');
        const vol = Number.isFinite(saved) && saved > 0 ? saved : 1;
        a.volume = vol;
        try { window.updateVolumeUI && window.updateVolumeUI(vol); } catch {}
      }
    } catch {}
  }

  // Публичный API
  window.PlayerControls = {
    togglePlayPause,
    previousTrack,
    nextTrack,
    stopPlayback,
    seekFromEvent,
    onVolumeInput,
    toggleMute
  };
})();

//=================================================
// FILE: /scripts/ci/lint-sw.mjs
#!/usr/bin/env node
import fs from 'node:fs';
import path from 'node:path';

const file = path.resolve('service-worker.js');
if (!fs.existsSync(file)) {
  console.error('service-worker.js not found');
  process.exit(1);
}
const src = fs.readFileSync(file, 'utf8');

const errors = [];
const warns = [];

if (!/const\s+SW_VERSION\s*=\s*['"`]\d+\.\d+\.\d+['"`]/.test(src)) {
  errors.push('SW_VERSION is missing or has wrong format (x.y.z)');
}

const listeners = (name) => (src.match(new RegExp(`addEventListener\\(['"]${name}['"]`, 'g')) || []).length;
['install','activate','fetch'].forEach(ev => {
  const n = listeners(ev);
  if (n === 0) errors.push(`No ${ev} event listener`);
  if (n > 1) warns.push(`Multiple (${n}) ${ev} listeners`);
});

const consts = ['CORE_CACHE','RUNTIME_CACHE','MEDIA_CACHE','OFFLINE_CACHE','META_CACHE'];
consts.forEach(cn => {
  const n = (src.match(new RegExp(`\\bconst\\s+${cn}\\b`, 'g')) || []).length;
  if (n === 0) errors.push(`Missing const ${cn}`);
  if (n > 1) warns.push(`Duplicate const ${cn} (${n} times)`);
});

// Доп.проверки: DEFAULT_SW_CONFIG числовые лимиты и revalidateDays целочисленное
const cfgMatch = src.match(/const\s+DEFAULT_SW_CONFIG\s*=\s*\{([\s\S]*?)\};/);
if (cfgMatch) {
  const body = cfgMatch[1];
  const num = (key) => {
    const m = body.match(new RegExp(`${key}\\s*:\\s*([0-9]+(?:\\.[0-9]+)?)`));
    return m ? Number(m[1]) : null;
  };
  const revalidateDays = num('revalidateDays');
  if (!(Number.isInteger(revalidateDays) && revalidateDays > 0)) {
    errors.push('DEFAULT_SW_CONFIG.revalidateDays must be positive integer');
  }
  ['mediaMaxCacheMB','nonRangeMaxStoreMB','nonRangeMaxStoreMBSlow'].forEach(k => {
    const v = num(k);
    if (!(typeof v === 'number' && v > 0)) errors.push(`DEFAULT_SW_CONFIG.${k} must be positive number`);
  });
}

if (warns.length) {
  console.warn('SW linter warnings:\n - ' + warns.join('\n - '));
}
if (errors.length) {
  console.error('SW linter errors:\n - ' + errors.join('\n - '));
  process.exit(2);
}
console.log('Service Worker lint OK');


//=================================================
// FILE: /scripts/ci/validate-content.mjs
#!/usr/bin/env node
import fs from 'node:fs';
import path from 'node:path';

const fail = (msg) => { console.error(msg); process.exit(2); };
const warn = (msg) => { console.warn(msg); };

// 1) albums.json базовая проверка
const albumsFile = path.resolve('albums.json');
if (!fs.existsSync(albumsFile)) fail('albums.json not found');
let albums;
try {
  const raw = fs.readFileSync(albumsFile, 'utf8');
  const j = JSON.parse(raw);
  if (!j || !Array.isArray(j.albums)) fail('albums.json: "albums" must be an array');
  albums = j.albums;
} catch (e) {
  fail('albums.json is not valid JSON: ' + e.message);
}
albums.forEach((a, i) => {
  if (!a.key || !a.title || !a.base) fail(`albums.json: album[${i}] must contain key/title/base`);
  if (typeof a.key !== 'string' || typeof a.title !== 'string' || typeof a.base !== 'string') {
    fail(`albums.json: album[${i}] key/title/base must be strings`);
  }
});

// 2) Проверка центральных галерей и index.json наличия/структуры
const galleryRoot = path.resolve('albums/gallery');
const required = ['00','01','02','news'];
required.forEach(id => {
  const dir = path.join(galleryRoot, id);
  const idx = path.join(dir, 'index.json');
  if (!fs.existsSync(dir)) fail(`albums/gallery/${id} directory missing`);
  if (!fs.existsSync(idx)) fail(`albums/gallery/${id}/index.json missing`);
  try {
    const raw = fs.readFileSync(idx, 'utf8');
    const j = JSON.parse(raw);
    const items = Array.isArray(j.items) ? j.items : (Array.isArray(j) ? j : []);
    if (!Array.isArray(items)) fail(`albums/gallery/${id}/index.json: items must be array`);
    if (items.length === 0) warn(`albums/gallery/${id}/index.json: items is empty`);
    // Локальные пути — проверяем существование файлов (если относительные)
    items.forEach((it, k) => {
      const check = (p) => {
        if (!p || /^https?:\/\//i.test(p)) return;
        const rel = p.replace(/^\.\//, '');
        const fp = path.resolve(rel);
        if (!fs.existsSync(fp)) warn(`Missing file referenced from gallery ${id} item[${k}]: ${p}`);
      };
      if (typeof it === 'string') check(it);
      else if (it && typeof it === 'object') {
        if (it.src) check(it.src);
        if (it.formats) Object.values(it.formats).forEach(check);
      }
    });
  } catch (e) {
    fail(`albums/gallery/${id}/index.json invalid JSON: ${e.message}`);
  }
});

// 3) custom.json sw конфиг: revalidateDays целое число
const customFile = path.resolve('custom.json');
if (fs.existsSync(customFile)) {
  try {
    const raw = fs.readFileSync(customFile, 'utf8');
    const j = JSON.parse(raw);
    if (j && j.sw) {
      const d = j.sw.revalidateDays;
      if (!(Number.isInteger(d) && d > 0)) {
        fail('custom.json.sw.revalidateDays must be positive integer');
      }
      ['mediaMaxCacheMB','nonRangeMaxStoreMB','nonRangeMaxStoreMBSlow'].forEach(key => {
        const v = j.sw[key];
        if (!(typeof v === 'number' && v > 0)) fail(`custom.json.sw.${key} must be positive number`);
      });
      if (typeof j.sw.allowUnknownSize !== 'boolean') {
        fail('custom.json.sw.allowUnknownSize must be boolean');
      }
    }
  } catch (e) {
    fail('custom.json invalid JSON: ' + e.message);
  }
}

console.log('Content validation OK');

//=================================================
// FILE: /scripts/ci/validate-manifest.mjs
#!/usr/bin/env node
import fs from 'node:fs';
import path from 'node:path';

const file = path.resolve('manifest.json');
if (!fs.existsSync(file)) {
  console.error('manifest.json not found');
  process.exit(1);
}
const raw = fs.readFileSync(file, 'utf8');
let json;
try {
  json = JSON.parse(raw);
} catch (e) {
  console.error('manifest.json is not valid JSON:', e.message);
  process.exit(1);
}
const errors = [];
function req(key) { if (!(key in json)) errors.push(`Missing key: ${key}`); }

req('name');
req('short_name');
req('start_url');
req('icons');

if (json.icons && !Array.isArray(json.icons)) {
  errors.push('icons must be an array');
}
if (Array.isArray(json.icons) && json.icons.length === 0) {
  errors.push('icons must contain at least one icon');
}
if (!json.display) errors.push('Missing key: display');
if (!json.theme_color) errors.push('Missing key: theme_color');
if (!json.background_color) errors.push('Missing key: background_color');

if (errors.length) {
  console.error('Manifest validation failed:\n - ' + errors.join('\n - '));
  process.exit(2);
}
console.log('Manifest validation OK');

//=================================================
// FILE: /scripts/ci/validate-playercore.mjs
#!/usr/bin/env node
import fs from 'node:fs';
import path from 'node:path';

const jsFile = path.resolve('src/PlayerCore.js');
const tsFile = path.resolve('src/PlayerCore.ts');

function read(p){ if(!fs.existsSync(p)){ console.error(`File not found: ${p}`); process.exit(2);} return fs.readFileSync(p,'utf8'); }
const js = read(jsFile);
const ts = read(tsFile);

function extractSnapshotKeys(src) {
  const m = src.match(/getPlaylistSnapshot\([\s\S]*?\)\s*\{[\s\S]*?return\s*\([\s\S]*?\.map\(\s*\w+\s*=>\s*\(\{\s*([\s\S]*?)\}\)\)\s*\)/);
  if (!m) return null;
  const body = m[1];
  const keys = new Set();
  for (const prop of body.split('\n')) {
    const mm = prop.match(/^\s*([a-zA-Z_][\w]*)\s*:/);
    if (mm) keys.add(mm[1]);
  }
  return [...keys];
}

function extractTsTrackFields(src) {
  const m = src.match(/export\s+type\s+PlayerTrack\s*=\s*\{([\s\S]*?)\};/);
  if (!m) return null;
  const body = m[1];
  const keys = new Set();
  for (const line of body.split('\n')) {
    const mm = line.match(/^\s*([a-zA-Z_][\w]*)\s*:/);
    if (mm) keys.add(mm[1]);
  }
  return [...keys];
}

const jsKeys = extractSnapshotKeys(js) || [];
const tsKeys = extractSnapshotKeys(ts) || [];
const tsTrack = extractTsTrackFields(ts) || [];

const expected = ['title','artist','album','cover','lyrics','src','fulltext'];

function fail(msg){ console.error('validate-playercore:', msg); process.exit(2); }

function sameSet(a,b){ const A=new Set(a), B=new Set(b); if (A.size!==B.size) return false; for (const k of A) if(!B.has(k)) return false; return true; }

if (!sameSet(jsKeys, expected)) {
  fail(`PlayerCore.js getPlaylistSnapshot keys mismatch. Got: [${jsKeys.join(', ')}], expected: [${expected.join(', ')}]`);
}
if (!sameSet(tsKeys, expected)) {
  fail(`PlayerCore.ts getPlaylistSnapshot keys mismatch. Got: [${tsKeys.join(', ')}], expected: [${expected.join(', ')}]`);
}

// track type must contain at least listed fields (some optional)
const requiredInTrack = ['src','title','artist','album','cover','lyrics','fulltext'];
const miss = requiredInTrack.filter(k => !tsTrack.includes(k));
if (miss.length) {
  fail(`PlayerCore.ts PlayerTrack is missing fields: ${miss.join(', ')}`);
}

console.log('PlayerCore JS/TS validation OK');

//=================================================
// FILE: /scripts/core/bootstrap.js
// scripts/core/bootstrap.js
// PlayerCoreObserver — централизатор событий PlayerCore.
// Позволяет добавлять несколько наблюдателей без перезаписи pc.events.
// Глобальный API:
//   window.PlayerCoreObserver.add(observer) -> id
//   window.PlayerCoreObserver.remove(id)
//   window.PlayerCoreObserver.attach(pc?)  // переустановить диспетчер (обычно не нужно)

(function initPlayerCoreObserver(){
  if (window.PlayerCoreObserver) return;

  const observers = new Map(); // id -> { onPlay, onPause, onStop, onTick, onTrackChange, onEnd, onSleepTriggered }
  let nextId = 1;
  let attachedPc = null;

  function dispatch(name, args) {
    // Вызовы в порядке добавления — без исключений, каждую ловим локально
    for (const [, ob] of observers) {
      const fn = ob && ob[name];
      if (typeof fn === 'function') {
        try { fn.apply(null, args); } catch {}
      }
    }
  }

  function bindTo(pc) {
    if (!pc || typeof pc.on !== 'function') return;
    attachedPc = pc;
    pc.on({
      onPlay:           (t, i) => dispatch('onPlay', [t, i]),
      onPause:          (t, i) => dispatch('onPause', [t, i]),
      onStop:           (t, i) => dispatch('onStop', [t, i]),
      onTrackChange:    (t, i) => dispatch('onTrackChange', [t, i]),
      onEnd:            (t, i) => dispatch('onEnd', [t, i]),
      onTick:           (p, d) => dispatch('onTick', [p, d]),
      onSleepTriggered: (t, i) => dispatch('onSleepTriggered', [t, i])
    });
  }

  function ensureAttached() {
    if (attachedPc && window.playerCore === attachedPc) return;
    if (window.playerCore) {
      bindTo(window.playerCore);
    }
  }

  const API = {
    add(observer) {
      ensureAttached();
      const id = nextId++;
      observers.set(id, observer || {});
      // Переустановки pc.on не требуется — диспетчер уже навешан; просто начнём вызывать нового наблюдателя
      return id;
    },
    remove(id) {
      observers.delete(id);
    },
    attach(pc) {
      bindTo(pc || window.playerCore || null);
    }
  };

  window.PlayerCoreObserver = API;

  // Попробуем привязаться, когда адаптер загрузится
  const id = setInterval(() => {
    if (window.playerCore) {
      try { bindTo(window.playerCore); } catch {}
      clearInterval(id);
    }
  }, 200);
  setTimeout(() => clearInterval(id), 10000);
})();


//=================================================
// FILE: /scripts/core/config.js
// scripts/core/config.js
// Централизованная конфигурация приложения

export const APP_CONFIG = {
  VERSION: '8.1.0',
  BUILD_DATE: '2025-12-06',
  PROMO_CODE: 'VITRINA2025',
  
  ALBUMS_FALLBACK: [
    {
      key: 'mezhdu-zlom-i-dobrom',
      title: 'Между Злом и Добром (2025)',
      base: 'https://apel-s-in.github.io/vi3na1bita-mezhdu-zlom-i-dobrom/'
    },
    {
      key: 'golos-dushi',
      title: 'Голос Души',
      base: 'https://apel-s-in.github.io/vi3na1bita-golos-dushi/'
    },
    {
      key: 'krevetochka',
      title: 'КРЕВЕцTOCHKA',
      base: 'https://apel-s-in.github.io/krevetochka/'
    }
  ],
  
  CENTRAL_GALLERY_BASE: './albums/gallery/',
  ALBUM_GALLERY_MAP: {
    'krevetochka': '00',
    'mezhdu-zlom-i-dobrom': '01',
    'golos-dushi': '02',
    '__reliz__': 'news'
  },
  
  ICON_ALBUMS_ORDER: [
    { key: '__favorites__', title: '⭐⭐⭐ИЗБРАННОЕ⭐⭐⭐', icon: 'img/icon_album/icon-album-00.png' },
    { key: 'golos-dushi', title: 'Голос Души', icon: 'img/icon_album/icon-album-02.png' },
    { key: 'mezhdu-zlom-i-dobrom', title: 'Между Злом и Добром', icon: 'img/icon_album/icon-album-01.png' },
    { key: 'krevetochka', title: 'КРЕВЕцTOCHKA', icon: 'img/icon_album/icon-album+00.png' },
    { key: '__reliz__', title: 'НОВОСТИ', icon: 'img/icon_album/icon-album-news.png' }
  ]
};

// Экспорт в window для обратной совместимости
if (typeof window !== 'undefined') {
  window.APP_CONFIG = APP_CONFIG;
  window.VERSION = APP_CONFIG.VERSION;
  window.ALBUMS_FALLBACK = APP_CONFIG.ALBUMS_FALLBACK;
  window.CENTRAL_GALLERY_BASE = APP_CONFIG.CENTRAL_GALLERY_BASE;
  window.ALBUM_GALLERY_MAP = APP_CONFIG.ALBUM_GALLERY_MAP;
  window.ICON_ALBUMS_ORDER = APP_CONFIG.ICON_ALBUMS_ORDER;
}

//=================================================
// FILE: /scripts/e2e/favorites.spec.js
// @ts-check
import { test, expect } from '@playwright/test';

const BASE = process.env.BASE_URL || 'http://127.0.0.1:4173';

test('favorites UI builds and plays from favorites list', async ({ page }) => {
  await page.goto(`${BASE}/index.html`, { waitUntil: 'load' });
  await page.fill('#promo-inp', 'VITRINA2025');
  await page.click('#promo-btn');

  // Отметим первый трек как избранный в текущем альбоме
  await page.waitForSelector('#track-list .track', { timeout: 10000 });
  const firstRow = page.locator('#track-list .track').first();
  await firstRow.hover();
  await firstRow.locator('.like-star').click();

  // Открыть «Избранное»
  await page.click('.album-icon[data-akey="__favorites__"]');

  // Должны увидеть хотя бы одну строку
  await page.waitForSelector('#track-list .track', { timeout: 10000 });
  const favCount = await page.locator('#track-list .track').count();
  expect(favCount).toBeGreaterThan(0);

  // Клик по первой строке — должен появиться блок плеера
  await page.locator('#track-list .track').first().click();
  await expect(page.locator('#lyricsplayerblock')).toBeVisible();
});

test('toggle star in favorites updates row state and localStorage', async ({ page }) => {
  await page.goto(`${BASE}/index.html`, { waitUntil: 'load' });
  await page.fill('#promo-inp', 'VITRINA2025');
  await page.click('#promo-btn');

  // Если пусто — отметим трек как избранный
  await page.waitForSelector('#track-list .track', { timeout: 10000 });
  const firstAlbumRow = page.locator('#track-list .track').first();
  await firstAlbumRow.hover();
  await firstAlbumRow.locator('.like-star').click();

  // Войти в «Избранное»
  await page.click('.album-icon[data-akey="__favorites__"]');
  await page.waitForSelector('#track-list .track', { timeout: 10000 });

  const favRow = page.locator('#track-list .track').first();
  const favId = await favRow.getAttribute('id'); // формат fav_{a}_{t}
  expect(favId).toMatch(/^fav_/);

  // Снимем звезду — строка станет .inactive и запись пропадёт из likedTracks:v2
  await favRow.locator('.like-star').click();

  await expect(favRow).toHaveClass(/inactive/);

  // Проверим localStorage: likedTracks:v2 больше не содержит эту ссылку
  const { albumKey, trackIdx, present } = await page.evaluate((id) => {
    const m = id.match(/^fav_(.+)_(\d+)$/);
    const a = m ? m[1] : '';
    const t = m ? parseInt(m[2], 10) : -1;
    const raw = localStorage.getItem('likedTracks:v2');
    const map = raw ? JSON.parse(raw) : {};
    const arr = Array.isArray(map[a]) ? map[a] : [];
    return { albumKey: a, trackIdx: t, present: arr.includes(t) };
  }, favId);

  expect(albumKey).toBeTruthy();
  expect(trackIdx).toBeGreaterThanOrEqual(0);
  expect(present).toBeFalsy();
});

test('favorites view: add to favorites, play and verify mini-mode when browsing other album', async ({ page }) => {
  const BASE = process.env.BASE_URL || 'http://127.0.0.1:4173';
  await page.goto(`${BASE}/index.html`, { waitUntil: 'load' });

  // Войти по промокоду
  await page.fill('#promo-inp', 'VITRINA2025');
  await page.click('#promo-btn');
  await page.waitForSelector('#track-list .track', { timeout: 10000 });

  // Отметить первый трек как избранный
  const firstTrack = page.locator('#track-list .track').first();
  await firstTrack.hover();
  const star = firstTrack.locator('.like-star');
  await star.click();

  // Открыть представление «Избранное» (иконка с data-akey="__favorites__")
  await page.click('.album-icon[data-akey="__favorites__"]');

  // Кликнуть по первой строке в «Избранном», если есть
  await page.waitForSelector('#track-list .track', { timeout: 10000 });
  const favFirst = page.locator('#track-list .track').first();
  await favFirst.click();

  // Плеер видим
  await expect(page.locator('#lyricsplayerblock')).toBeVisible();

  // Переключиться на другой альбом (например, второй значок, не Favorites и не News)
  const otherIcon = page.locator('.album-icon').filter({ hasNot: page.locator('[data-akey="__favorites__"]') }).nth(1);
  await otherIcon.click();

  // Проверить, что появился mini-режим (мини-шапка)
  await expect(page.locator('#mini-now')).toBeVisible();
});

// Доп. тест: восстановление после перезагрузки (PlayerState.applyState)
test('reload restores state via PlayerState.applyState', async ({ page }) => {
  await page.goto(`${BASE}/index.html`, { waitUntil: 'load' });
  await page.fill('#promo-inp', 'VITRINA2025');
  await page.click('#promo-btn');
  await page.waitForSelector('#track-list .track', { timeout: 10000 });
  await page.click('#track-list .track >> nth=0');
  await page.waitForSelector('#lyricsplayerblock', { timeout: 10000 });

  // Сохраним состояние вручную (эмулируем PlayerState.save)
  await page.evaluate(() => {
    const pc = window.playerCore;
    const st = {
      album: window.currentAlbumKey || null,
      trackIndex: 0,
      position: Math.floor(pc?.getSeek?.() || 5),
      volume: pc?.getVolume?.() ?? 1,
      wasPlaying: true
    };
    localStorage.setItem('playerStateV1', JSON.stringify(st));
  });

  await page.reload({ waitUntil: 'load' });
  await page.fill('#promo-inp', 'VITRINA2025'); // после reload может снова спросить промо
  await page.click('#promo-btn');

  await page.waitForSelector('#lyricsplayerblock', { timeout: 10000 });
  const pos = await page.evaluate(() => Math.floor(window.playerCore?.getSeek?.() || 0));
  expect(pos).toBeGreaterThanOrEqual(0);
});

// Опциональный тест setSinkId: скип, если не поддерживается
test('optional audio output setSinkId (skip when unsupported)', async ({ page }) => {
  await page.goto(`${BASE}/index.html`, { waitUntil: 'load' });
  await page.fill('#promo-inp', 'VITRINA2025');
  await page.click('#promo-btn');
  await page.waitForSelector('#track-list .track', { timeout: 10000 });
  await page.click('#track-list .track >> nth=0');

  const supported = await page.evaluate(() => {
    const dest = (window.Howler && window.Howler.ctx && window.Howler.ctx.destination) ? window.Howler.ctx.destination : null;
    return !!(dest && typeof dest.setSinkId === 'function' && navigator.mediaDevices);
  });
  // Ничего не ассертим: тест опциональный.
});

test('sysinfo modal shows after GET_SW_INFO', async ({ page }) => {
  const BASE = process.env.BASE_URL || 'http://127.0.0.1:4173';
  await page.goto(`${BASE}/index.html`, { waitUntil: 'load' });
  await page.fill('#promo-inp', 'VITRINA2025');
  await page.click('#promo-btn');

  // Ждём ини SW
  await page.waitForTimeout(800);
  const sysbtn = page.locator('#sysinfo-btn');
  await expect(sysbtn).toBeVisible({ timeout: 5000 });
  await sysbtn.click();

  const modal = page.locator('.modal-bg .modal-feedback').filter({ hasText: 'О системе' });
  await expect(modal).toBeVisible({ timeout: 5000 });
  await expect(modal).toContainText(/SW версия:/);
});

// Новый тест: быстрые клики Prev/Next сразу после старта — не запускают legacy <audio>
test('quick prev/next uses PlayerCore only (no legacy audio starts)', async ({ page }) => {
  await page.goto(`${BASE}/index.html`, { waitUntil: 'load' });
  await page.fill('#promo-inp', 'VITRINA2025');
  await page.click('#promo-btn');

  await page.waitForSelector('#track-list .track', { timeout: 10000 });
  await page.click('#track-list .track >> nth=0');

  await page.evaluate(async () => {
    await new Promise(r => setTimeout(r, 50));
    window.PlayerControls && window.PlayerControls.previousTrack && window.PlayerControls.previousTrack();
    window.PlayerControls && window.PlayerControls.nextTrack && window.PlayerControls.nextTrack();
  });

  const res = await page.evaluate(() => ({
    hasPc: !!window.playerCore,
    hasAudioEl: !!document.getElementById('audio')
  }));
  expect(res.hasPc).toBeTruthy();
  expect(res.hasAudioEl).toBeFalsy();
});

test('SW update flow persists state and restores after reload', async ({ page }) => {
  await page.goto(`${BASE}/index.html`, { waitUntil: 'load' });
  await page.fill('#promo-inp', 'VITRINA2025');
  await page.click('#promo-btn');
  await page.waitForSelector('#track-list .track', { timeout: 10000 });
  await page.click('#track-list .track >> nth=0');
  await page.waitForTimeout(200);
  await page.evaluate(() => {
    if (window.playerCore && typeof window.playerCore.play === 'function') {
      window.playerCore.play(0);
      try { window.playerCore.seek(7); } catch {}
    }
  });

  await page.evaluate(() => {
    window.confirm = () => true;
    const evt = new MessageEvent('message', { data: { type: 'SW_VERSION', version: '9.9.9' } });
    try { navigator.serviceWorker && navigator.serviceWorker.dispatchEvent && navigator.serviceWorker.dispatchEvent(evt); } catch {}
  });

  const hasResume = await page.evaluate(() => !!sessionStorage.getItem('resumeAfterReloadV1'));
  expect(hasResume).toBeTruthy();

  await page.reload({ waitUntil: 'load' });
  await page.fill('#promo-inp', 'VITRINA2025');
  await page.click('#promo-btn');

  await page.waitForSelector('#lyricsplayerblock', { timeout: 10000 });
  const pos = await page.evaluate(() => Math.floor(window.playerCore?.getSeek?.() || 0));
  expect(pos).toBeGreaterThanOrEqual(0);
});

// НОВЫЙ ТЕСТ: снял звезду у текущего в режиме Избранного → next() и UI обновился
test('favorites playing: removing star of current track triggers next and updates UI', async ({ page }) => {
  await page.goto(`${BASE}/index.html`, { waitUntil: 'load' });
  await page.fill('#promo-inp', 'VITRINA2025');
  await page.click('#promo-btn');

  // Отметим первый трек как избранный в альбоме
  await page.waitForSelector('#track-list .track', { timeout: 10000 });
  const firstAlbumRow = page.locator('#track-list .track').first();
  await firstAlbumRow.hover();
  await firstAlbumRow.locator('.like-star').click();

  // Откроем «Избранное» и запустим воспроизведение первого трека
  await page.click('.album-icon[data-akey="__favorites__"]');
  await page.waitForSelector('#track-list .track', { timeout: 10000 });
  const favFirst = page.locator('#track-list .track').first();
  await favFirst.click();
  await expect(page.locator('#lyricsplayerblock')).toBeVisible();

  // Снимем звезду на этой же строке
  const beforeIdx = await page.evaluate(() => (window.playerCore?.getIndex?.() ?? window.playingTrack ?? 0));
  await favFirst.locator('.like-star').click();

  // Должен переключиться следующий трек
  await page.waitForTimeout(300);
  const afterIdx = await page.evaluate(() => (window.playerCore?.getIndex?.() ?? window.playingTrack ?? 0));
  expect(afterIdx).not.toBe(beforeIdx);

  // Строка стала inactive, а класс .current должен подсветить другой элемент
  await expect(favFirst).toHaveClass(/inactive/);
  const currentCount = await page.locator('#track-list .track.current').count();
  expect(currentCount).toBe(1);

  // Если сейчас мини-режим возможен — «Далее»/мини-шапка обновятся без ошибок (не строго ассертим видимость)
  await page.evaluate(() => {
    window.MiniUI && window.MiniUI.updateNextUpLabel && window.MiniUI.updateNextUpLabel();
    window.MiniUI && window.MiniUI.updateMiniNowHeader && window.MiniUI.updateMiniNowHeader();
  });
});

//=================================================
// FILE: /scripts/e2e/player.spec.js
// @ts-check
import { test, expect } from '@playwright/test';

const BASE = process.env.BASE_URL || 'http://127.0.0.1:4173';

test('play track, toggle favorites-only and sleep timer UI', async ({ page }) => {
  await page.goto(`${BASE}/index.html`, { waitUntil: 'load' });

  // Вход по промокоду
  await page.fill('#promo-inp', 'VITRINA2025');
  await page.click('#promo-btn');
  await expect(page.locator('#main-block')).toBeVisible();

  // Дождаться списка альбомов и клик по первой строке треклиста
  await page.waitForSelector('#track-list .track', { timeout: 10000 });
  const firstTrack = page.locator('#track-list .track').first();
  await firstTrack.click();

  // Появился блок плеера и кнопка Play/Pause есть
  await expect(page.locator('#lyricsplayerblock')).toBeVisible();
  await expect(page.locator('#play-pause-icon')).toBeVisible();

  // Включаем фильтр "только избранные" (кнопка в плеере)
  await page.click('#favorites-btn');
  const favBtn = page.locator('#favorites-btn');
  await expect(favBtn).toHaveClass(/favorites-active/);

  // Таймер сна: открыть меню и выбрать "15 минут", затем выключить
  await page.click('#sleep-timer-btn');
  await page.click('.sleep-menu-item:has-text("15 минут")');
  // Бейдж должен появиться
  await expect(page.locator('#sleep-timer-badge')).toBeVisible();
  // Выключим
  await page.click('#sleep-timer-btn');
  await page.click('.sleep-menu-item:has-text("Выключить")');
  await expect(page.locator('#sleep-timer-badge')).toBeHidden();
});

test('favorites view: add to favorites, play and verify mini-mode when browsing other album', async ({ page }) => {
  const BASE = process.env.BASE_URL || 'http://127.0.0.1:4173';
  await page.goto(`${BASE}/index.html`, { waitUntil: 'load' });

  // Войти по промокоду
  await page.fill('#promo-inp', 'VITRINA2025');
  await page.click('#promo-btn');
  await page.waitForSelector('#track-list .track', { timeout: 10000 });

  // Отметить первый трек как избранный
  const firstTrack = page.locator('#track-list .track').first();
  await firstTrack.hover();
  const star = firstTrack.locator('.like-star');
  await star.click();

  // Открыть представление «Избранное» (иконка с data-akey="__favorites__")
  await page.click('.album-icon[data-akey="__favorites__"]');

  // Кликнуть по первой строке в «Избранном», если есть
  await page.waitForSelector('#track-list .track', { timeout: 10000 });
  const favFirst = page.locator('#track-list .track').first();
  await favFirst.click();

  // Плеер видим
  await expect(page.locator('#lyricsplayerblock')).toBeVisible();

  // Переключиться на другой альбом (например, второй значок, не Favorites и не News)
  const otherIcon = page.locator('.album-icon').filter({ hasNot: page.locator('[data-akey="__favorites__"]') }).nth(1);
  await otherIcon.click();

  // Проверить, что появился mini-режим (мини-шапка)
  await expect(page.locator('#mini-now')).toBeVisible();
});

// Доп. тест: восстановление после перезагрузки (PlayerState.applyState)
test('reload restores state via PlayerState.applyState', async ({ page }) => {
  await page.goto(`${BASE}/index.html`, { waitUntil: 'load' });
  await page.fill('#promo-inp', 'VITRINA2025');
  await page.click('#promo-btn');
  await page.waitForSelector('#track-list .track', { timeout: 10000 });
  await page.click('#track-list .track >> nth=0');
  await page.waitForSelector('#lyricsplayerblock', { timeout: 10000 });

  // Сохраним состояние вручную (эмулируем PlayerState.save) — чтобы тест был детерминированным
  await page.evaluate(() => {
    const pc = window.playerCore;
    const st = {
      album: window.currentAlbumKey || null,
      trackIndex: 0,
      position: Math.floor(pc?.getSeek?.() || 5),
      volume: pc?.getVolume?.() ?? 1,
      wasPlaying: true
    };
    localStorage.setItem('playerStateV1', JSON.stringify(st));
  });

  await page.reload({ waitUntil: 'load' });
  await page.fill('#promo-inp', 'VITRINA2025'); // после reload может снова спросить промо
  await page.click('#promo-btn');

  await page.waitForSelector('#lyricsplayerblock', { timeout: 10000 });
  // Проверим, что воспроизведение продолжается (или готово продолжиться) и индекс/позиция восстановлены близко к сохранённым
  const pos = await page.evaluate(() => Math.floor(window.playerCore?.getSeek?.() || 0));
  expect(pos).toBeGreaterThanOrEqual(0); // допускаем расхождение, главное — не с нуля
});

// Опциональный тест setSinkId: скип, если не поддерживается
test('optional audio output setSinkId (skip when unsupported)', async ({ page }) => {
  await page.goto(`${BASE}/index.html`, { waitUntil: 'load' });
  await page.fill('#promo-inp', 'VITRINA2025');
  await page.click('#promo-btn');
  await page.waitForSelector('#track-list .track', { timeout: 10000 });
  await page.click('#track-list .track >> nth=0');

  const supported = await page.evaluate(() => {
    const dest = (window.Howler && window.Howler.ctx && window.Howler.ctx.destination) ? window.Howler.ctx.destination : null;
    return !!(dest && typeof dest.setSinkId === 'function' && navigator.mediaDevices);
  });
  // Ничего не ассертим: тест опциональный. Просто не падаем.
});

test('sysinfo modal shows after GET_SW_INFO', async ({ page }) => {
  const BASE = process.env.BASE_URL || 'http://127.0.0.1:4173';
  await page.goto(`${BASE}/index.html`, { waitUntil: 'load' });
  await page.fill('#promo-inp', 'VITRINA2025');
  await page.click('#promo-btn');

  // Ждём ини SW
  await page.waitForTimeout(800);
  // Кнопка «О СИСТЕМЕ» показывается на desktop
  const sysbtn = page.locator('#sysinfo-btn');
  await expect(sysbtn).toBeVisible({ timeout: 5000 });
  await sysbtn.click();

  // Появляется модалка
  const modal = page.locator('.modal-bg .modal-feedback').filter({ hasText: 'О системе' });
  await expect(modal).toBeVisible({ timeout: 5000 });

  // В модалке есть версия SW
  await expect(modal).toContainText(/SW версия:/);
});

// Новый тест: быстрые клики Prev/Next сразу после старта — не запускают legacy <audio>
test('quick prev/next uses PlayerCore only (no legacy audio starts)', async ({ page }) => {
  await page.goto(`${BASE}/index.html`, { waitUntil: 'load' });
  await page.fill('#promo-inp', 'VITRINA2025');
  await page.click('#promo-btn');

  await page.waitForSelector('#track-list .track', { timeout: 10000 });
  await page.click('#track-list .track >> nth=0');

  // Быстро вызовем prev/next через публичный API
  await page.evaluate(async () => {
    // Возможна лентивка адаптера — подождём минимально
    await new Promise(r => setTimeout(r, 50));
    window.PlayerControls && window.PlayerControls.previousTrack && window.PlayerControls.previousTrack();
    window.PlayerControls && window.PlayerControls.nextTrack && window.PlayerControls.nextTrack();
  });

  // Проверяем: PlayerCore есть, legacy <audio> не создан
  const res = await page.evaluate(() => ({
    hasPc: !!window.playerCore,
    hasAudioEl: !!document.getElementById('audio')
  }));
  expect(res.hasPc).toBeTruthy();
  expect(res.hasAudioEl).toBeFalsy();
});

// Новый тест: имитируем SW_VERSION → сохраняется state, после reload восстанавливается
test('SW update flow persists state and restores after reload', async ({ page }) => {
  await page.goto(`${BASE}/index.html`, { waitUntil: 'load' });
  await page.fill('#promo-inp', 'VITRINA2025');
  await page.click('#promo-btn');
  await page.waitForSelector('#track-list .track', { timeout: 10000 });
  await page.click('#track-list .track >> nth=0');
  // Немного подождём и установим позицию через PlayerCore (если доступен)
  await page.waitForTimeout(200);
  await page.evaluate(() => {
    if (window.playerCore && typeof window.playerCore.play === 'function') {
      window.playerCore.play(0);
      try { window.playerCore.seek(7); } catch {}
    }
  });

  // Авто-принятие confirm и отправка fake SW_VERSION
  await page.evaluate(() => {
    window.confirm = () => true;
    const evt = new MessageEvent('message', { data: { type: 'SW_VERSION', version: '9.9.9' } });
    try { navigator.serviceWorker && navigator.serviceWorker.dispatchEvent && navigator.serviceWorker.dispatchEvent(evt); } catch {}
  });

  // Проверим, что стейт для реюма записан
  const hasResume = await page.evaluate(() => !!sessionStorage.getItem('resumeAfterReloadV1'));
  expect(hasResume).toBeTruthy();

  // Перезагрузим страницу и снова пройдём промо
  await page.reload({ waitUntil: 'load' });
  await page.fill('#promo-inp', 'VITRINA2025');
  await page.click('#promo-btn');

  // После восстановления позиция не должна быть «с нуля»
  await page.waitForSelector('#lyricsplayerblock', { timeout: 10000 });
  const pos = await page.evaluate(() => Math.floor(window.playerCore?.getSeek?.() || 0));
  expect(pos).toBeGreaterThanOrEqual(0);
});

//=================================================
// FILE: /scripts/energy.js


//=================================================
// FILE: /scripts/player-adapter.js
// scripts/player-adapter.js (ESM)
// Адаптер: создаём window.playerCore на основе src/PlayerCore.js,
// не вмешиваясь в существующий UI и <audio> на этом этапе.

import { PlayerCore } from '../src/PlayerCore.js';

(function initPlayerCoreAdapter() {
  if (window.playerCore) return;

  // Создаём ядро без событий (позже навесим onTick/onPlay и т.п. при маршрутизации UI)
  const pc = new PlayerCore();

  // Применим сохранённые режимы (без влияния на текущий <audio>)
  try {
    const vol = parseFloat(localStorage.getItem('playerVolume') || '1');
    if (Number.isFinite(vol)) pc.setVolume(vol);
  } catch {}
  try { pc.setRepeat(localStorage.getItem('repeatMode') === '1'); } catch {}
  try { pc.setShuffle(localStorage.getItem('shuffleMode') === '1'); } catch {}
  try {
    const favOnly = localStorage.getItem('favoritesOnlyMode') === '1';
    // Если уже играем «ИЗБРАННОЕ» — фильтр в ядре не нужен (плейлист уже отфильтрован)
    const isFavoritesCtx = (window.playingAlbumKey === window.SPECIAL_FAVORITES_KEY);
    const likedIdx = (!isFavoritesCtx && window.playingAlbumKey && window.getLikedForAlbum)
      ? window.getLikedForAlbum(window.playingAlbumKey)
      : [];
    pc.setFavoritesOnly(isFavoritesCtx ? false : favOnly, likedIdx);
  } catch {}

  // Экспортируем в глобальную область
  window.playerCore = pc;

  // Немедленно прикрепить диспетчер событий (без ожидания таймера в bootstrap)
  try {
    if (window.PlayerCoreObserver && typeof window.PlayerCoreObserver.attach === 'function') {
      window.PlayerCoreObserver.attach(pc);
    }
  } catch {}

  // Если уже есть активный контекст — передадим ЕГО в ядро.
  // ВАЖНО: больше НИКОГДА не подсовываем сюда «просто текущий альбом».
  // Плейлист устанавливается только явно из UI (showTrack/ensureFavoritesPlayback).
  try {
    if (Array.isArray(window.playingTracks) && window.playingTracks.length) {
      const cover = window.playingCover || (window.coverGalleryArr?.[0]?.formats?.full) || 'img/logo.png';
      const tracks = window.playingTracks.map(t => ({
        src: t.audio,
        title: t.title,
        artist: window.playingArtist || 'Витрина Разбита',
        album: window.playingAlbumName || 'Альбом',
        cover,
        lyrics: t.lyrics,
        fulltext: t.fulltext || ''
      }));
      const meta = {
        artist: window.playingArtist || 'Витрина Разбита',
        album: window.playingAlbumName || 'Альбом',
        cover
      };
      const index = (Number.isInteger(window.playingTrack) && window.playingTrack >= 0) ? window.playingTrack : 0;
      pc.setPlaylist(tracks, index, meta);
    }
  } catch {}

  // Никаких обработчиков событий и управления DOM пока не вешаем — UI остаётся в старом режиме
})();

//=================================================
// FILE: /scripts/ui/favorites-const.js
// scripts/ui/favorites-const.js
// Единая точка правды для ключей/констант «Избранного».
// Важна обратная совместимость: прокинем в window, чтобы их видел inline-код index.html.

const SPECIAL_FAVORITES_KEY = '__favorites__';
const SPECIAL_RELIZ_KEY = '__reliz__';

// Ключ хранилища лайков (V2)
const LIKED_STORAGE_KEY_V2 = 'likedTracks:v2';

// Ключ хранилища ссылок «Избранного» (refs)
const FAVORITES_REFS_KEY = 'favoritesAlbumRefs:v1';

// Back-compat для существующего inline-кода:
Object.assign(window, {
  SPECIAL_FAVORITES_KEY,
  SPECIAL_RELIZ_KEY,
  LIKED_STORAGE_KEY_V2,
  FAVORITES_REFS_KEY,
});

//=================================================
// FILE: /scripts/ui/favorites-data.js
// scripts/ui/favorites-data.js
// Data-хелперы «Избранного» + TTL-кэш обложек.
// Экспортирует совместимые функции в window.* для обратной совместимости.

(function FavoritesDataModule() {
  const w = window;

  const FAVORITES_REFS_KEY = window.FAVORITES_REFS_KEY || 'favoritesAlbumRefs:v1';
  const COVER_TTL_MS = 12 * 60 * 60 * 1000; // 12 часов
  const albumCoverCache = Object.create(null); // { [albumKey]: { url:string, ts:number } }

  // Безопасные геттеры likedTracks:v2
  function getLikedMap() {
    try { const raw = localStorage.getItem('likedTracks:v2'); const obj = raw ? JSON.parse(raw) : {}; return obj && typeof obj === 'object' ? obj : {}; }
    catch { return {}; }
  }
  function getLikedForAlbum(albumKey) {
    try {
      const map = getLikedMap();
      const arr = (map && typeof map === 'object') ? map[albumKey] : [];
      if (!Array.isArray(arr)) return [];
      // Нормализуем к числам и убираем дубли
      const norm = Array.from(new Set(arr.map(n => parseInt(n, 10)).filter(Number.isFinite)));
      return norm;
    } catch {
      return [];
    }
  }

  function readFavoritesRefs() {
    try { const raw = localStorage.getItem(FAVORITES_REFS_KEY); const arr = raw ? JSON.parse(raw) : []; return Array.isArray(arr) ? arr : []; }
    catch { return []; }
  }
  function writeFavoritesRefs(arr) {
    try { localStorage.setItem(FAVORITES_REFS_KEY, JSON.stringify(Array.isArray(arr) ? arr : [])); } catch {}
  }

  function ensureFavoritesRefsWithLikes() {
    const refs = readFavoritesRefs();
    const keySet = new Set(refs.map(x => `${x.a}:${x.t}`));

    try {
      const map = getLikedMap();
      const albumsIndex = Array.isArray(w.albumsIndex) ? w.albumsIndex : [];

      // Объединяем ключи из albumsIndex и likedTracks:v2 — это устраняет случай,
      // когда в albums.json временно нет альбома, но в likedTracks он ещё есть.
      const indexKeys = albumsIndex.map(a => a && a.key).filter(Boolean);
      const likedKeys = Object.keys(map || {});
      const allKeysSet = new Set([...indexKeys, ...likedKeys]);

      for (const akey of allKeysSet) {
        const liked = Array.isArray(map?.[akey]) ? map[akey] : [];
        for (const ti of liked) {
          const k = `${akey}:${ti}`;
          if (!keySet.has(k)) {
            refs.push({ a: akey, t: ti });
            keySet.add(k);
          }
        }
      }
    } catch {}

    writeFavoritesRefs(refs);
    return refs;
  }

  function getSortedFavoritesRefs() {
    const refs = ensureFavoritesRefsWithLikes().slice();
    const ICON_ALBUMS_ORDER = (w.ICON_ALBUMS_ORDER || []).map(x => x.key)
      .filter(k => k !== w.SPECIAL_FAVORITES_KEY && k !== w.SPECIAL_RELIZ_KEY);
    const orderMap = new Map(ICON_ALBUMS_ORDER.map((k, i) => [k, i]));
    refs.sort((r1, r2) => {
      const o1 = orderMap.has(r1.a) ? orderMap.get(r1.a) : 999;
      const o2 = orderMap.has(r2.a) ? orderMap.get(r2.a) : 999;
      if (o1 !== o2) return o1 - o2;
      return (r1.t - r2.t);
    });
    return refs;
  }

  async function getAlbumConfigByKey(albumKey) {
    if (!albumKey) return null;
    const albumConfigCache = w.albumConfigCache || {};

    // Канонический ключ для alias
    let realKey = albumKey;
    if (typeof w.resolveRealAlbumKey === 'function') {
      try {
        const cand = w.resolveRealAlbumKey(albumKey);
        if (cand) realKey = cand;
      } catch {}
    }

    // 1) Пробуем кэш по обоим ключам
    if (albumConfigCache[albumKey]?.config) return albumConfigCache[albumKey].config;
    if (albumConfigCache[realKey]?.config)  return albumConfigCache[realKey].config;

    // 2) Ищем meta по каноническому ключу (предпочтение realKey)
    const albumsIndex = w.albumsIndex || [];
    const meta = (albumsIndex.find(a => a && a.key === realKey) ||
                  albumsIndex.find(a => a && a.key === albumKey)) || null;
    if (!meta) return null;

    const base = (typeof w.normalizeBase === 'function') ? w.normalizeBase(meta.base) : meta.base;
    const absJoin = typeof w.absJoin === 'function'
      ? w.absJoin
      : ((b, r) => new URL(String(r || ''), String(b || '') + '/').toString());

    try {
      const r = await fetch(absJoin(base, 'config.json'), { cache: 'no-cache' });
      if (!r || !r.ok) return null;
      const data = await r.json();
      (data.tracks || []).forEach(t => {
        t.audio   = absJoin(base, t.audio);
        t.lyrics  = absJoin(base, t.lyrics);
        if (t.fulltext) t.fulltext = absJoin(base, t.fulltext);
      });

      // 3) Кладём в кэш под ОБОИМИ ключами (alias и canonical)
      albumConfigCache[realKey]  = { base, config: data };
      albumConfigCache[albumKey] = { base, config: data };
      w.albumConfigCache = albumConfigCache;

      return data;
    } catch {
      return null;
    }
  }

  async function getAlbumCoverUrl(albumKey) {
    const now = Date.now();

    // 1) sessionStorage-кэш
    try {
      const sKey = `favCoverCache:v1:${albumKey}`;
      const raw = sessionStorage.getItem(sKey);
      if (raw) {
        const obj = JSON.parse(raw);
        if (obj && obj.url && obj.ts && (now - obj.ts) < COVER_TTL_MS) {
          albumCoverCache[albumKey] = { url: obj.url, ts: obj.ts };
          return obj.url;
        }
      }
    } catch {}

    // 2) in-memory кэш
    const cache = albumCoverCache[albumKey];
    if (cache && (now - cache.ts) < COVER_TTL_MS) return cache.url;

    // 3) загрузка index.json галереи
    try {
      const centralIdForAlbumKey = w.centralIdForAlbumKey;
      const normalizeGalleryItem = w.normalizeGalleryItem;
      const CENTRAL_GALLERY_BASE = w.CENTRAL_GALLERY_BASE || './albums/gallery/';
      const cid = typeof centralIdForAlbumKey === 'function' ? centralIdForAlbumKey(albumKey) : null;
      if (!cid) {
        albumCoverCache[albumKey] = { url: 'img/logo.png', ts: now };
        try { sessionStorage.setItem(`favCoverCache:v1:${albumKey}`, JSON.stringify({ url: 'img/logo.png', ts: now })); } catch {}
        return 'img/logo.png';
      }
      const baseDir = `${CENTRAL_GALLERY_BASE}${cid}/`;
      const r = await fetch(baseDir + 'index.json', { cache: 'force-cache' });
      if (r.ok) {
        const j = await r.json();
        const first = Array.isArray(j.items) ? j.items[0] : (Array.isArray(j) ? j[0] : null);
        if (first) {
          const norm = typeof normalizeGalleryItem === 'function' ? normalizeGalleryItem(first, baseDir) : first;
          const url = (norm && (norm.formats?.webp || norm.formats?.full || norm.src)) || 'img/logo.png';
          albumCoverCache[albumKey] = { url, ts: now };
          try { sessionStorage.setItem(`favCoverCache:v1:${albumKey}`, JSON.stringify({ url, ts: now })); } catch {}
          return url;
        }
      }
    } catch {}

    albumCoverCache[albumKey] = { url: 'img/logo.png', ts: now };
    try { sessionStorage.setItem(`favCoverCache:v1:${albumKey}`, JSON.stringify({ url: 'img/logo.png', ts: now })); } catch {}
    return 'img/logo.png';
  }

  async function buildFavoritesRefsModel() {
    const sortedRefs = getSortedFavoritesRefs();
    const out = [];

    for (const ref of sortedRefs) {
      // Активность — всегда из likedTracks:v2
      const active = getLikedForAlbum(ref.a).includes(ref.t);

      // Пытаемся получить конфиг альбома и целевой трек
      let cfg = null;
      try { cfg = await getAlbumConfigByKey(ref.a); } catch {}
      const tr = cfg?.tracks?.[ref.t] || null;

      // Обложку стараемся получить из центральной галереи (устойчивее к CORS)
      const cover = await getAlbumCoverUrl(ref.a);

      if (tr && tr.audio) {
        out.push({
          title: tr.title,
          audio: tr.audio,
          lyrics: tr.lyrics,
          fulltext: tr.fulltext || null,
          __a: ref.a,
          __t: ref.t,
          __artist: cfg?.artist || 'Витрина Разбита',
          __album: cfg?.albumName || 'Альбом',
          __active: active,
          __cover: cover
        });
        continue;
      }

      // Fallback: нет конфига или трека — строим «неиграбельную» строку (показываем, но не запускаем)
      try {
        const albumMeta =
          (Array.isArray(w.albumsIndex) ? w.albumsIndex.find(a => a && a.key === ref.a) : null) || null;
        const albumTitle =
          (albumMeta && albumMeta.title) ||
          (w.ICON_TITLE_MAP && w.ICON_TITLE_MAP[ref.a]) ||
          ref.a;

        out.push({
          title: `Трек ${String((ref.t || 0) + 1).padStart(2, '0')}`,
          audio: null,                // важный признак: такой элемент не должен стартовать
          lyrics: null,
          fulltext: null,
          __a: ref.a,
          __t: ref.t,
          __artist: 'Витрина Разбита',
          __album: albumTitle,
          __active: active,
          __cover: cover
        });
      } catch {
        // как крайний случай — пропустим ссылку, чтобы не зашумлять список
      }
    }

    w.favoritesRefsModel = out;
    return out;
  }

  function updateFavoritesRefsModelActiveFlag(albumKey, trackIndex, isActive) {
    const model = w.favoritesRefsModel;
    if (!Array.isArray(model)) return;
    const item = model.find(x => x.__a === albumKey && x.__t === trackIndex);
    if (item) item.__active = !!isActive;
  }

  // Экспорт API
  w.FavoritesData = {
    readFavoritesRefs,
    writeFavoritesRefs,
    ensureFavoritesRefsWithLikes,
    getSortedFavoritesRefs,
    getAlbumConfigByKey,
    buildFavoritesRefsModel,
    updateFavoritesRefsModelActiveFlag,
    getAlbumCoverUrl
  };

  // Совместимость со старым кодом (глобали)
  w.readFavoritesRefs = readFavoritesRefs;
  w.writeFavoritesRefs = writeFavoritesRefs;
  w.ensureFavoritesRefsWithLikes = ensureFavoritesRefsWithLikes;
  w.getSortedFavoritesRefs = getSortedFavoritesRefs;
  w.getAlbumConfigByKey = getAlbumConfigByKey;
  w.buildFavoritesRefsModel = buildFavoritesRefsModel;
  w.updateFavoritesRefsModelActiveFlag = updateFavoritesRefsModelActiveFlag;

})();

//=================================================
// FILE: /scripts/ui/favorites-storage.js
// scripts/ui/favorites-storage.js
// Операции с localStorage для лайков.
// Чистая логика без DOM. Работает как обычный скрипт, кладёт функции в window.

// Берём ключ либо из favorites-const.js, либо fallback.
const __LIKED_KEY = (typeof window.LIKED_STORAGE_KEY_V2 === 'string')
  ? window.LIKED_STORAGE_KEY_V2
  : 'likedTracks:v2';

function getLikedMap() {
  try {
    const raw = localStorage.getItem(__LIKED_KEY);
    const map = raw ? JSON.parse(raw) : {};
    return (map && typeof map === 'object') ? map : {};
  } catch {
    return {};
  }
}

function getLikedForAlbum(albumKey) {
  try {
    const raw = localStorage.getItem(__LIKED_KEY);
    const map = raw ? JSON.parse(raw) : {};
    const arr = (map && typeof map === 'object') ? map[albumKey] : [];
    // Нормализуем к числам и убираем дубликаты
    return Array.from(new Set((Array.isArray(arr) ? arr : [])
      .map(n => parseInt(n, 10))
      .filter(Number.isFinite)));
  } catch {
    return [];
  }
}

function toggleLikeForAlbum(albumKey, idx, makeLiked) {
  const index = parseInt(idx, 10);
  if (!Number.isFinite(index)) return;
  const map = getLikedMap();
  const arrRaw = Array.isArray(map[albumKey]) ? map[albumKey] : [];
  const arr = Array.from(new Set(arrRaw
    .map(n => parseInt(n, 10))
    .filter(Number.isFinite)));
  const has = arr.includes(index);

  let next = arr.slice();
  if (makeLiked && !has) next.push(index);
  if (!makeLiked && has) next = next.filter(x => x !== index);

  map[albumKey] = next;
  try { localStorage.setItem(__LIKED_KEY, JSON.stringify(map)); } catch {}
}

// Back-compat: оставляем глобальные имена, которые уже вызывает index.html
Object.assign(window, {
  getLikedMap,
  getLikedForAlbum,
  toggleLikeForAlbum,
});

//=================================================
// FILE: /scripts/ui/favorites.js
// scripts/ui/favorites.js
// UI «Избранного», гармонизированный с likedTracks:v2.
// Централизует ВСЮ механику UI «Избранного» и вспомогательные операции фильтрации.
// Добавлено: "пустой стейт" при пустом favoritesRefsModel и защита от двойных кликов по звезде (≈180 мс).
(function FavoritesUIModule() {
  const w = window;

  // Безопасные прокси к глобальным функциям/данным
  const hasFn = (name) => typeof w[name] === 'function';
  const call = (name, ...args) => (hasFn(name) ? w[name](...args) : undefined);
  const get = (name, dflt) => (name in w ? w[name] : dflt);

  // likedTracks:v2 helpers
  function getLikedMapSafe() {
    try {
      if (hasFn('getLikedMap')) return w.getLikedMap();
      const raw = localStorage.getItem('likedTracks:v2');
      const map = raw ? JSON.parse(raw) : {};
      return (map && typeof map === 'object') ? map : {};
    } catch { return {}; }
  }
  function setLikedMapSafe(map) {
    try { localStorage.setItem('likedTracks:v2', JSON.stringify(map || {})); } catch {}
  }
  function getLikedForAlbumSafe(albumKey) {
    try {
      if (hasFn('getLikedForAlbum')) return w.getLikedForAlbum(albumKey);
      const map = getLikedMapSafe();
      const arr = map && typeof map === 'object' ? map[albumKey] : [];
      return Array.isArray(arr) ? arr : [];
    } catch { return []; }
  }

  // Декоратор от двойных кликов: защита 180 мс
  let __lastStarClickTs = 0;
  function guardStarClick() {
    const now = Date.now();
    if (now - __lastStarClickTs < 180) return true;
    __lastStarClickTs = now;
    return false;
  }

  // Обновление класса .current в списке «Избранного»
  function updateFavoritesCurrentRow(idx) {
    const list = document.getElementById('track-list');
    if (!list) return;

    try {
      document.querySelectorAll('#track-list .track').forEach(el => el.classList.remove('current'));
    
      // ✅ Обратное отображение: playable[idx] → model[i]
      const origIdx = Array.isArray(w.favPlayableMap) && w.favPlayableMap[idx] !== undefined
        ? w.favPlayableMap[idx]
        : idx;
    
      const rows = list.querySelectorAll('.track');
      const row = origIdx >= 0 && origIdx < rows.length ? rows[origIdx] : null;
      if (row) row.classList.add('current');
    } catch {}

    // Размещение блока плеера
    try {
      const lp = document.getElementById('lyricsplayerblock');
      if (!lp) {
        if (hasFn('renderLyricsBlock')) call('renderLyricsBlock');
        return;
      }

      const origIdx = (Array.isArray(w.favPlayableMap) && Number.isInteger(w.favPlayableMap[idx]))
        ? w.favPlayableMap[idx]
        : idx;
      const rows = list.querySelectorAll('.track');
      const rowUnder = origIdx >= 0 && origIdx < rows.length ? rows[origIdx] : null;

      if (rowUnder && lp && rowUnder.parentNode) {
        const isCorrectPosition = rowUnder.nextSibling === lp || (rowUnder.nextSibling === null && rowUnder.parentNode.lastChild === lp);

        if (!isCorrectPosition) {
          if (rowUnder.nextSibling) {
            rowUnder.parentNode.insertBefore(lp, rowUnder.nextSibling);
          } else {
            rowUnder.parentNode.appendChild(lp);
          }
        }
      }

      // Принудительно обновляем UI плеера
      call('restorePlayerButtonsState');
      call('applyLyricsViewMode');
      call('initializePlayerControls');
      call('applyMiniModeUI');
      call('updateMiniNowHeader');
      call('updateNextUpLabel');
      call('updatePlayPauseIcon');

    } catch {}
  }

  // Обновление .is-favorite в «Избранном»
  function updateFavoriteClassesFavorites() {
    try {
      const model = w.favoritesRefsModel;
      if (!Array.isArray(model)) return;
      document.querySelectorAll('#track-list .track').forEach(tr => tr.classList.remove('is-favorite'));
      model.forEach((item) => {
        if (item && item.__active) {
          const el = document.getElementById(`fav_${item.__a}_${item.__t}`);
          if (el) el.classList.add('is-favorite');
        }
      });
    } catch {}
  }

  // Обновление .is-favorite в альбомном представлении
  function updateFavoriteClasses() {
    try {
      const liked = hasFn('getLiked') ? w.getLiked() : [];
      document.querySelectorAll('#track-list .track').forEach(tr => tr.classList.remove('is-favorite'));
      liked.forEach(idx => {
        const el = document.getElementById(`trk${idx}`);
        if (el) el.classList.add('is-favorite');
      });
    } catch {}
  }

  // Изменить лайк (запись в likedTracks:v2)
  function toggleLikeForAlbum(albumKey, idx, makeLiked) {
    const map = getLikedMapSafe();
    const arr = Array.isArray(map[albumKey]) ? map[albumKey] : [];
    const has = arr.includes(idx);
    let next = arr.slice();
    if (makeLiked && !has) next.push(idx);
    if (!makeLiked && has) next = next.filter(x => x !== idx);
    map[albumKey] = Array.from(new Set(next));
    setLikedMapSafe(map);
  }

  // UI‑обновление одной строки «Избранного»
  function updateFavRow(ref, active) {
    const row = document.getElementById(`fav_${ref.a}_${ref.t}`);
    if (!row) return;
    row.classList.toggle('inactive', !active);
    const star = row.querySelector('.like-star');
    if (star) {
      star.src = active ? 'img/star.png' : 'img/star2.png';
      star.title = active ? 'Снять из избранного' : 'Вернуть в избранное';
    }
  }

  // Модалка: трек неактивен в «Избранном»
  function showFavInactivePrompt(ref) {
    const modal = document.createElement('div');
    modal.className = 'modal-bg active';
    modal.innerHTML = `
      <div class="modal-feedback" style="max-width: 380px;">
        <button class="bigclose" onclick="this.closest('.modal-bg').remove()" title="Закрыть">
          <svg viewBox="0 0 48 48"><line x1="12" y1="12" x2="36" y2="36" stroke="currentColor" stroke-width="6" stroke-linecap="round"/><line x1="36" y1="12" x2="12" y2="36" stroke="currentColor" stroke-width="6" stroke-linecap="round"/></svg>
        </button>
        <div style="font-weight:700; margin-bottom:10px;">Трек неактивен</div>
        <div style="opacity:.8; margin-bottom:14px;">
          Чтобы снова слушать трек в «ИЗБРАННОМ», добавьте его в избранное в исходном альбоме.
          Также можно удалить ссылку из этого списка.
        </div>
        <div style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap;">
          <button class="offline-btn online" style="min-width:140px;" id="fav-add-btn">Добавить в ⭐</button>
          <button class="offline-btn" style="min-width:140px;" id="fav-del-btn">Удалить</button>
        </div>
      </div>`;
    document.body.appendChild(modal);

    const onAdd = () => {
      toggleLikeForAlbum(ref.a, ref.t, true);
      updateFavRow(ref, true);
      call('updateFavoritesRefsModelActiveFlag', ref.a, ref.t, true);
      modal.remove();
      w.NotificationSystem && w.NotificationSystem.success('Добавлено в избранное');
    };
    const onDel = () => { modal.remove(); showFavDeleteConfirm(ref); };

    modal.querySelector('#fav-add-btn').onclick = onAdd;
    modal.querySelector('#fav-del-btn').onclick = onDel;
  }

  // Модалка: подтверждение удаления ссылки из «Избранного»
  function showFavDeleteConfirm(ref) {
    const modal = document.createElement('div');
    modal.className = 'modal-bg active';
    modal.innerHTML = `
      <div class="modal-feedback" style="max-width: 390px;">
        <button class="bigclose" onclick="this.closest('.modal-bg').remove()" title="Закрыть">
          <svg viewBox="0 0 48 48"><line x1="12" y1="12" x2="36" y2="36" stroke="currentColor" stroke-width="6" stroke-linecap="round"/><line x1="36" y1="12" x2="12" y2="36" stroke="currentColor" stroke-width="6" stroke-linecap="round"/></svg>
        </button>
        <div style="font-weight:700; margin-bottom:10px;">Удалить из «ИЗБРАННОГО»?</div>
        <div style="opacity:.8; margin-bottom:12px;">
          Трек исчезнет из списка «ИЗБРАННОЕ», но останется доступным в исходном альбоме.
        </div>
        <div style="display:flex; gap:10px; justify-content:center;">
          <button class="offline-btn" style="min-width:120px;" id="fav-del-cancel">Отмена</button>
          <button class="offline-btn online" style="min-width:120px;" id="fav-del-apply">Удалить</button>
        </div>
      </div>`;
    document.body.appendChild(modal);

    const onCancel = () => modal.remove();
    const onApply = () => {
      try {
        const refs = call('readFavoritesRefs') || [];
        const next = refs.filter(x => !(x.a === ref.a && x.t === ref.t));
        call('writeFavoritesRefs', next);
      } catch {}
      document.getElementById(`fav_${ref.a}_${ref.t}`)?.remove();

      try {
        if (Array.isArray(w.favoritesRefsModel)) {
          w.favoritesRefsModel = w.favoritesRefsModel.filter(x => !(x.__a === ref.a && x.__t === ref.t));
          const rows = document.querySelectorAll('#track-list .track');
          rows.forEach((row, i) => {
            const tnum = row.querySelector('.tnum');
            if (tnum) tnum.textContent = `${String(i + 1).padStart(2, '0')}.`;
          });
        }
      } catch {}

      modal.remove();
      w.NotificationSystem && w.NotificationSystem.success('Удалено из «ИЗБРАННОГО»');
    };

    modal.querySelector('#fav-del-cancel').onclick = onCancel;
    modal.querySelector('#fav-del-apply').onclick = onApply;
  }

  // Пустой стейт (UX) для favoritesRefsModel
  function renderEmptyState(list) {
    const el = document.createElement('div');
    el.style.cssText = 'text-align:center; opacity:.85; margin:12px 6px; padding:10px; border:1px dashed rgba(255,255,255,.18); border-radius:8px; background:rgba(255,255,255,.04)';
    el.innerHTML = `
      <div style="font-weight:800; margin-bottom:6px;">В «ИЗБРАННОМ» пока пусто</div>
      <div style="font-size:.95em;">
        Откройте любой альбом и отметьте понравившиеся песни звездой ⭐ — они появятся здесь.
      </div>`;
    list.appendChild(el);
  }

  // Главная функция: построение и показ представления «Избранное»
  async function openFavoritesView() {
    call('applyRelizUiMode', false);
    w.viewMode = 'favorites';
    call('clearRelizView');
    call('setActiveAlbumIcon', w.SPECIAL_FAVORITES_KEY);
    call('setAlbumHeaderTitle', w.SPECIAL_FAVORITES_KEY);

    // Сбрасываем карту соответствия (будет создана при старте воспроизведения)
    w.favPlayableMap = null;

    // Гарантируем загрузку списка альбомов (для сборки избранного)
    if ((!Array.isArray(w.albumsIndex) || w.albumsIndex.length === 0) && hasFn('loadAlbumsIndex')) {
      try { await call('loadAlbumsIndex'); } catch {}
    }

    try { w.migrateFavoritesKeys && w.migrateFavoritesKeys(); } catch {}

    // Перенос плеера
    try {
      const lp = document.getElementById('lyricsplayerblock');
      const holder = document.getElementById('now-playing');
      if (lp && holder && !holder.contains(lp)) { holder.innerHTML = ''; holder.appendChild(lp); }
    } catch {}

    call('applyMiniModeUI');

    // Скрываем галерею
    const cw = document.getElementById('cover-wrap');
    if (cw) cw.style.display = 'none';

    // Жёстко сбрасываем предыдущее состояние фильтра «⭐»
    try {
      w.favoritesFilterActive = false;
      const listEl = document.getElementById('track-list');
      const filterBtn = document.getElementById('filter-favorites-btn');
      if (listEl) listEl.classList.remove('filtered');
      if (filterBtn) {
        filterBtn.classList.remove('filtered');
        filterBtn.textContent = 'Скрыть не отмеченные ⭐ песни';
      }
    } catch {}

    // Сбор модели «Избранного»
    if (hasFn('buildFavoritesRefsModel')) {
      await call('buildFavoritesRefsModel');
    }

    // Рисуем список
    const list = document.getElementById('track-list');
    if (!list) return;
    list.style.display = '';
    list.innerHTML = '<div style="text-align:center; opacity:.8; margin:6px 0 8px 0;">ИЗБРАННЫЕ ПЕСНИ</div>';

    const model = Array.isArray(w.favoritesRefsModel) ? w.favoritesRefsModel : [];
    if (!model.length) {
      renderEmptyState(list);
      call('applyMiniModeUI');
      list.classList.remove('filtered');
      return;
    }

    model.forEach((item, idx) => {
      const n = String(idx + 1).padStart(2, '0');
      const row = document.createElement('div');
      row.className = 'track' + (item.__active ? '' : ' inactive');
      row.id = `fav_${item.__a}_${item.__t}`;
      row.innerHTML = `
        <span class="tnum">${n}.</span>
        <span class="track-title" title="${item.title} — ${item.__album}">
          ${item.title} <span style="opacity:.6;font-size:.9em;">— ${item.__album}</span>
        </span>
        <img src="${item.__active ? 'img/star.png' : 'img/star2.png'}" class="like-star" alt="звезда"
             title="${item.__active ? 'Снять из избранного' : 'Вернуть в избранное'}">
      `;

      // Клик по строке — играем, если активен; иначе подсказка
      row.addEventListener('click', async (e) => {
        if (e) e.stopPropagation();
        
        const canPlay = !!item.__active && !!item.audio;
        if (canPlay) {
          try {
            // ✅ КРИТИЧНО: явно устанавливаем контекст «ИЗБРАННОГО» ДО вызова
            w.viewMode = 'favorites';
            w.playingAlbumKey = w.SPECIAL_FAVORITES_KEY;
            
            await ensureFavoritesPlayback({
              a: item.__a,
              t: item.__t,
              idx: idx
            });
          } catch (e) {
            console.error('ensureFavoritesPlayback failed:', e);
            w.NotificationSystem && w.NotificationSystem.error('Не удалось запустить трек');
          }
        } else {
          showFavInactivePrompt({ a: item.__a, t: item.__t, title: item.title, album: item.__album });
        }
      });

      // Клик по звезде — смена статуса (с защитой от двойного клика)
      row.querySelector('.like-star').addEventListener('click', (e) => {
        e.stopPropagation();
        if (guardStarClick()) return;

        const wasActive = getLikedForAlbumSafe(item.__a).includes(item.__t);
        toggleLikeForAlbum(item.__a, item.__t, !wasActive);
        updateFavRow({ a: item.__a, t: item.__t }, !wasActive);
        call('updateFavoritesRefsModelActiveFlag', item.__a, item.__t, !wasActive);

        // Если сейчас играем «Избранное» — поддержим последовательность и UI
        if (w.playingAlbumKey === w.SPECIAL_FAVORITES_KEY && Array.isArray(w.playingTracks)) {
          try {
            // ✅ ПОЛНАЯ пересборка playable + карты
            const model = w.favoritesRefsModel || [];
            const playable = [];
            const modelToPlayableMap = new Map();

            model.forEach((it, i) => {
              if (it && it.__active && it.audio) {
                const j = playable.length;
                playable.push({ it, i });
                modelToPlayableMap.set(i, j);
              }
            });

            w.favPlayableMap = playable.map(x => x.i);
            w.favModelToPlayableMap = modelToPlayableMap;
          } catch {}

          if (wasActive) {
            call('createPlayingShuffledPlaylist');
            call('nextTrack');
            w.NotificationSystem && w.NotificationSystem.info('Трек снят из избранного');
          } else {
            call('createPlayingShuffledPlaylist');
            call('updateNextUpLabel');
            w.NotificationSystem && w.NotificationSystem.success('Трек возвращён в избранное');
          }
        } else {
          if (wasActive) w.NotificationSystem && w.NotificationSystem.info('Трек снят из избранного');
          else w.NotificationSystem && w.NotificationSystem.success('Трек возвращён в избранное');
        }

        // Синхронизация с PlayerCore
        if (w.__useNewPlayerCore && w.playerCore && typeof w.playerCore.setFavoritesOnly === 'function') {
          try {
            if (w.playingAlbumKey === w.SPECIAL_FAVORITES_KEY) {
              w.playerCore.setFavoritesOnly(false, []);
            } else {
              const likedIdx = getLikedForAlbumSafe(w.playingAlbumKey);
              w.playerCore.setFavoritesOnly(!!w.favoritesOnlyMode, likedIdx);
            }
          } catch {}
        }
      });

      list.appendChild(row);
    });

    // Если сейчас играет «Избранное» — подсветим текущую и подставим плеер под строку
    if (w.playingAlbumKey === w.SPECIAL_FAVORITES_KEY && typeof w.playingTrack === 'number' && w.playingTrack >= 0) {
      updateFavoritesCurrentRow(w.playingTrack);
      const listTracks = Array.from(document.querySelectorAll('#track-list .track'));
      const rowUnder = listTracks[w.playingTrack];
      const lp = document.getElementById('lyricsplayerblock');
      if (rowUnder && lp && rowUnder.parentNode) {
        if (rowUnder.nextSibling) rowUnder.parentNode.insertBefore(lp, rowUnder.nextSibling);
        else rowUnder.parentNode.appendChild(lp);
      }
    }

    call('applyMiniModeUI');
    list.classList.remove('filtered');
  }

  // Переключение «Скрыть не отмеченные ⭐ песни»
  function toggleFavoritesFilter() {
    const btn = document.getElementById('filter-favorites-btn');
    const list = document.getElementById('track-list');
    if (!btn || !list) return;

    let favoritesFilterActive = get('favoritesFilterActive', false);
    const viewMode = get('viewMode', 'album');

    if (viewMode === 'favorites') {
      favoritesFilterActive = !favoritesFilterActive;
      w.favoritesFilterActive = favoritesFilterActive;

      if (favoritesFilterActive) {
        const anyActive = (w.favoritesRefsModel || []).some(x => x.__active);
        if (!anyActive) {
          w.favoritesFilterActive = false;
          w.NotificationSystem && w.NotificationSystem.warning('Нет активных треков со ⭐!');
          return;
        }
        btn.textContent = 'ПОКАЗАТЬ ВСЕ ПЕСНИ';
        btn.classList.add('filtered');
        list.classList.add('filtered');
        updateFavoriteClassesFavorites();
      } else {
        btn.textContent = 'Скрыть не отмеченные ⭐ песни';
        btn.classList.remove('filtered');
        list.classList.remove('filtered');
      }
      return;
    }

    // Обычный альбом
    const liked = hasFn('getLiked') ? w.getLiked() : [];
    favoritesFilterActive = !favoritesFilterActive;
    w.favoritesFilterActive = favoritesFilterActive;

    if (favoritesFilterActive) {
      if (!liked.length) {
        w.NotificationSystem && w.NotificationSystem.warning('Нет избранных треков!');
        w.favoritesFilterActive = false;
        return;
      }
      btn.textContent = 'ПОКАЗАТЬ ВСЕ ПЕСНИ';
      btn.classList.add('filtered');
      list.classList.add('filtered');
      updateFavoriteClasses();
    } else {
      btn.textContent = 'Скрыть не отмеченные ⭐ песни';
      btn.classList.remove('filtered');
      list.classList.remove('filtered');
    }
  }

  // ИНИЦИАЛИЗАЦИЯ ВОСПРОИЗВЕДЕНИЯ ДЛЯ «ИЗБРАННОГО»
  async function ensureFavoritesPlayback(target) {
    // Обеспечим модель
    if (!Array.isArray(w.favoritesRefsModel) || w.favoritesRefsModel.length === 0) {
      await (w.FavoritesData?.buildFavoritesRefsModel?.() ?? Promise.resolve([]));
    }

    const model = Array.isArray(w.favoritesRefsModel) ? w.favoritesRefsModel : [];

    // Пересобираем playable‑плейлист и карту соответствия МОДЕЛЬ → PLAYABLE
    const playable = [];
    const modelToPlayableMap = new Map();

    model.forEach((it, i) => {
      if (it && it.__active && it.audio) {
        const j = playable.length;
        playable.push({ it, i });      // i — индекс в favoritesRefsModel
        modelToPlayableMap.set(i, j);  // j — индекс в playingTracks / PlayerCore
      }
    });

    if (!playable.length) {
      w.NotificationSystem && w.NotificationSystem.warning('Нет активных треков со ⭐');
      return;
    }

    // Глобальная карта: playableIndex -> modelIndex
    w.favPlayableMap = playable.map(x => x.i);
    // Обратная карта: modelIndex -> playableIndex
    w.favModelToPlayableMap = modelToPlayableMap;

    // Определение целевого индекса в playable
    let targetIdx = 0;

    if (typeof target === 'object' && target !== null) {
      const modelIdx = Number.isFinite(target.idx) ? target.idx : -1;
      
      if (modelIdx >= 0 && modelToPlayableMap.has(modelIdx)) {
        targetIdx = modelToPlayableMap.get(modelIdx);
      } else {
        const keyOf = (a, t) => `${a}:${t}`;
        const targetKey = keyOf(target.a, target.t);
        const found = playable.findIndex(x => keyOf(x.it.__a, x.it.__t) === targetKey);
        if (found >= 0) targetIdx = found;
      }
    } else if (typeof target === 'number') {
      targetIdx = Math.max(0, Math.min(playable.length - 1, target));
    }

    w.playingTrackOriginalIdx = targetIdx;

    // ✅ Контекст «Избранного»
    w.playingAlbumKey = w.SPECIAL_FAVORITES_KEY;
    w.viewMode = 'favorites';
    
    w.playingTracks = playable.map(x => ({
      title: x.it.title,
      audio: x.it.audio,
      lyrics: x.it.lyrics,
      fulltext: x.it.fulltext || null,
      artist: x.it.__artist || 'Витрина Разбита',
      album: x.it.__album || 'Избранное',
      cover: x.it.__cover || 'img/logo.png'
    }));
    w.playingArtist = 'Витрина Разбита';
    w.playingAlbumName = 'Избранное';
    w.playingCover = (playable[0]?.it?.__cover) || 'img/logo.png';
    w.playingTrack = targetIdx;
    w.currentTrack = targetIdx;

    w.favPlayableMap = playable.map(x => x.i);
    call('updateAvailableTracks');

    const holder = document.getElementById('now-playing');
    if (holder && !document.getElementById('lyricsplayerblock')) {
      holder.innerHTML = '<div class="lyrics-player-block" id="lyricsplayerblock"></div>';
      call('renderLyricsBlock');
    }

    // Если активен новый плеер
    if (w.__useNewPlayerCore && w.playerCore) {
      try {
        const payload = hasFn('__buildPlayerCorePayload') ? call('__buildPlayerCorePayload') : null;
        if (payload) {
          w.playerCore.setPlaylist(payload.tracks, targetIdx, payload.meta);
          w.playerCore.setShuffle(!!w.shuffleMode);
          w.playerCore.setRepeat(!!w.repeatMode);
          w.playerCore.setFavoritesOnly(false, []);
        }

        w.playerCore.play(targetIdx);

        if (payload?.tracks?.[targetIdx]?.lyrics) {
          call('loadLyrics', payload.tracks[targetIdx].lyrics);
        }

        call('restorePlayerButtonsState');
        call('applyLyricsViewMode');
        call('initializePlayerControls');
        call('applyMiniModeUI');
        call('updateMiniNowHeader');
        call('updateNextUpLabel');
        call('updatePlayPauseIcon');

        if (w.viewMode === 'favorites') {
          updateFavoritesCurrentRow(targetIdx);
        }

        return;
      } catch (e) {
        console.warn('ensureFavoritesPlayback via PlayerCore failed, falling back to <audio>', e);
        localStorage.setItem('newPlayerCore', '0');
        w.__useNewPlayerCore = false;
      }
    }

    // СТАРАЯ ВЕТКА (<audio>)
    try {
      const audio = document.getElementById('audio');
      if (!audio) return;

      const tr = w.playingTracks[targetIdx];
      if (!tr) return;

      audio.src = tr.audio;
      audio.currentTime = 0;

      const isIOSStandalone = hasFn('isIOSStandalone') ? call('isIOSStandalone') : false;
      if (isIOSStandalone) { audio.load(); }

      const p = audio.play();
      if (p && p.catch) p.catch(()=>{});

      if (tr.lyrics) call('loadLyrics', tr.lyrics);

      call('restorePlayerButtonsState');
      call('applyLyricsViewMode');
      call('initializePlayerControls');
      call('applyMiniModeUI');
      call('updateMiniNowHeader');
      call('updateNextUpLabel');

      if (w.viewMode === 'favorites') {
        updateFavoritesCurrentRow(targetIdx);
      }

    } catch (e) {
      console.error('Error in ensureFavoritesPlayback', e);
    }
  }

  // Переключение лайка у текущего играемого трека
  function toggleLikePlaying() {
    if (!w.playingTracks || w.playingTrack < 0) return;

    let albumForLike = w.playingAlbumKey;
    let indexForLike = w.playingTrack;

    if (w.playingAlbumKey === w.SPECIAL_FAVORITES_KEY) {
      const refIdx = w.favPlayableMap?.[w.playingTrack] ?? w.playingTrack;
      const ref = w.favoritesRefsModel?.[refIdx];
      if (!ref) return;
      albumForLike = ref.__a;
      indexForLike = ref.__t;
    }

    const map = getLikedMapSafe();
    const arr = Array.isArray(map[albumForLike]) ? map[albumForLike] : [];
    const was = arr.includes(indexForLike);
    const next = was ? arr.filter(x => x !== indexForLike) : [...arr, indexForLike];
    map[albumForLike] = Array.from(new Set(next));
    setLikedMapSafe(map);

    call('updateMiniNowHeader');

    if (w.playingAlbumKey === w.SPECIAL_FAVORITES_KEY) {
      w.FavoritesData?.updateFavoritesRefsModelActiveFlag?.(albumForLike, indexForLike, !was);
      const favRow = document.getElementById(`fav_${albumForLike}_${indexForLike}`);
      if (favRow) {
        favRow.classList.toggle('inactive', was);
        const s = favRow.querySelector('.like-star');
        if (s) {
          s.src = was ? 'img/star2.png' : 'img/star.png';
          s.title = was ? 'Вернуть в избранное' : 'Снять из избранного';
        }
      }
      try {
        const playable = (w.favoritesRefsModel || []).map((it, i) => ({ it, i }))
          .filter(x => x.it && x.it.__active && x.it.audio);
        w.favPlayableMap = playable.map(x => x.i);
      } catch {}

      call('createPlayingShuffledPlaylist');
      call('updateNextUpLabel');

      if (was) { call('nextTrack'); }
    } else {
      const favRow = document.getElementById(`fav_${albumForLike}_${indexForLike}`);
      if (favRow) {
        favRow.classList.toggle('inactive', was);
        const s = favRow.querySelector('.like-star');
        if (s) {
          s.src = was ? 'img/star2.png' : 'img/star.png';
          s.title = was ? 'Вернуть в избранное' : 'Снять из избранного';
        }
      }
      if (w.favoritesOnlyMode && w.shuffleMode) {
        call('createPlayingShuffledPlaylist');
      }
      call('updateNextUpLabel');
    }

    // Синхронизация с PlayerCore
    if (w.__useNewPlayerCore && w.playerCore && typeof w.playerCore.setFavoritesOnly === 'function') {
      try {
        if (w.playingAlbumKey === w.SPECIAL_FAVORITES_KEY) {
          w.playerCore.setFavoritesOnly(false, []);
        } else {
          const likedIdx = getLikedForAlbumSafe(w.playingAlbumKey);
          w.playerCore.setFavoritesOnly(!!w.favoritesOnlyMode, likedIdx);
          if (w.favoritesOnlyMode && was && hasFn('isBrowsingSameAsPlaying') && call('isBrowsingSameAsPlaying')) {
            setTimeout(() => { call('nextTrack'); }, 0);
          }
        }
      } catch {}
    }
  }

  // Публичный API
  const FavoritesUI = {
    openFavoritesView,
    updateFavoritesCurrentRow,
    updateFavoriteClassesFavorites,
    updateFavRow,
    toggleLikeForAlbum,
    showFavInactivePrompt,
    showFavDeleteConfirm,
    updateFavoriteClasses,
    toggleFavoritesFilter,
    ensureFavoritesPlayback,
    toggleLikePlaying
  };

  w.FavoritesUI = FavoritesUI;

  // Глобальные привязки (для onclick и вызовов из index.html)
  w.openFavoritesView = FavoritesUI.openFavoritesView;
  w.updateFavoritesCurrentRow = FavoritesUI.updateFavoritesCurrentRow;
  w.updateFavoriteClassesFavorites = FavoritesUI.updateFavoriteClassesFavorites;
  w.updateFavRow = FavoritesUI.updateFavRow;
  w.toggleLikeForAlbum = FavoritesUI.toggleLikeForAlbum;
  w.showFavInactivePrompt = FavoritesUI.showFavInactivePrompt;
  w.showFavDeleteConfirm = FavoritesUI.showFavDeleteConfirm;
  w.updateFavoriteClasses = FavoritesUI.updateFavoriteClasses;
  w.toggleFavoritesFilter = FavoritesUI.toggleFavoritesFilter;
  w.ensureFavoritesPlayback = FavoritesUI.ensureFavoritesPlayback;
  w.toggleLikePlaying = FavoritesUI.toggleLikePlaying;

})();

//=================================================
// FILE: /scripts/ui/mini.js
// scripts/ui/mini.js
// Мини-режим плеера: закрепление блока сверху, мини-шапка, "Далее: ...",
// звезда в мини и переход к играющему альбому.
// Контракт с PlayerCore: getIndex/getNextIndex/getPlaylistSnapshot.

(function(){
  function pc() {
    return (window.__useNewPlayerCore && window.playerCore) ? window.playerCore : null;
  }

  function isMiniMode() {
    try {
      if (window.viewMode === 'favorites' && window.playingAlbumKey === window.SPECIAL_FAVORITES_KEY) return false;
      return typeof window.isBrowsingOtherAlbum === 'function' ? window.isBrowsingOtherAlbum() : false;
    } catch { return false; }
  }

  function ensurePinnedTop(lp) {
    if (!lp) return;
    try {
      const holder = document.getElementById('now-playing');
      if (holder && lp.parentNode !== holder) {
        holder.innerHTML = '';
        holder.appendChild(lp);
      }
    } catch {}
  }

  function ensureNextUpLabel() {
    // Разметка создаётся в renderLyricsBlock; здесь лишь обновление текста/видимости
    const el = document.getElementById('next-up');
    return !!el;
  }

  function computeCurrentIndex() {
    const core = pc();
    let idx = -1;

    if (core && typeof core.getIndex === 'function') {
      const v = Number(core.getIndex());
      if (Number.isFinite(v) && v >= 0) idx = v;
    } else if (typeof window.playingTrack === 'number' && window.playingTrack >= 0) {
      idx = window.playingTrack;
    } else if (typeof window.currentTrack === 'number' && window.currentTrack >= 0) {
      idx = window.currentTrack;
    }

    // В режиме ИЗБРАННОГО нужно отразить индекс обратно в модель favoritesRefsModel
    if (idx >= 0 && window.playingAlbumKey === window.SPECIAL_FAVORITES_KEY && Array.isArray(window.favPlayableMap)) {
      const modelIdx = window.favPlayableMap[idx];
      return Number.isFinite(modelIdx) && modelIdx >= 0 ? modelIdx : idx;
    }

    return idx;
  }

  function computeTitleForIndex(idx) {
    if (idx < 0) return '—';

    // В ИЗБРАННОМ idx уже модельный индекс (favoritesRefsModel)
    if (window.playingAlbumKey === window.SPECIAL_FAVORITES_KEY && Array.isArray(window.favoritesRefsModel)) {
      const it = window.favoritesRefsModel[idx];
      return it && it.title ? it.title : '—';
    }

    const core = pc();
    if (core && typeof core.getPlaylistSnapshot === 'function') {
      try {
        const snap = core.getPlaylistSnapshot();
        const t = Array.isArray(snap) ? snap[idx] : null;
        return (t && t.title) ? t.title : '—';
      } catch {}
    }
    try {
      const arr = Array.isArray(window.playingTracks) ? window.playingTracks : (window.config?.tracks || []);
      return (arr && arr[idx] && arr[idx].title) ? arr[idx].title : '—';
    } catch { return '—'; }
  }

  function updateMiniNowHeader() {
    const box = document.getElementById('mini-now');
    if (!box) return;

    const mini = isMiniMode();
    const idx = computeCurrentIndex();

    // Мини показываем только когда листаем другой альбом и есть валидный индекс
    if (!mini || idx < 0) {
      box.style.display = 'none';
      return;
    }

    box.style.display = 'flex';
    const numEl = document.getElementById('mini-now-num');
    const titleEl = document.getElementById('mini-now-title');
    if (numEl) numEl.textContent = `${String(idx + 1).padStart(2, '0')}.`;
    if (titleEl) titleEl.textContent = computeTitleForIndex(idx);

    try {
      const liked = (typeof window.isLikedInPlayback === 'function') ? window.isLikedInPlayback(idx) : false;
      const starEl = document.getElementById('mini-now-star');
      if (starEl) {
        starEl.src = liked ? 'img/star.png' : 'img/star2.png';
        starEl.title = liked ? 'Убрать из понравившихся' : 'Добавить в понравившиеся';
      }
    } catch {}
  }

  function updateNextUpLabel() {
    const box = document.getElementById('next-up');
    const lp = document.getElementById('lyricsplayerblock');
    if (!box || !lp) return;

    // Показываем в мини-режиме
    if (!isMiniMode()) {
      box.style.display = 'none';
      return;
    }

    const core = pc();
    if (core && typeof core.getNextIndex === 'function') {
      try {
        const nextIdx = Number(core.getNextIndex());
        if (!Number.isFinite(nextIdx) || nextIdx < 0) {
          box.style.display = 'none';
          return;
        }
        const snap = (typeof core.getPlaylistSnapshot === 'function') ? core.getPlaylistSnapshot() : null;
        const title = (Array.isArray(snap) && snap[nextIdx] && snap[nextIdx].title) ? snap[nextIdx].title : '—';
        const label = `${String(nextIdx + 1).padStart(2, '0')}. ${title}`;
        const titleEl = box.querySelector('.title');
        if (titleEl) { titleEl.textContent = label; titleEl.title = label; }
        box.style.display = '';
        return;
      } catch {
        // мягкий фолбэк ниже
      }
    }

    try {
      if (!Array.isArray(window.playingTracks) || !window.playingTracks.length) {
        box.style.display = 'none';
        return;
      }
      const cand = (typeof window.computeNextIndexPlayback === 'function') ? window.computeNextIndexPlayback() : -1;
      if (!Number.isFinite(cand) || cand < 0) {
        box.style.display = 'none';
        return;
      }
      const title = window.playingTracks[cand]?.title || '—';
      const label = `${String(cand + 1).padStart(2, '0')}. ${title}`;
      const titleEl = box.querySelector('.title');
      if (titleEl) { titleEl.textContent = label; titleEl.title = label; }
      box.style.display = '';
    } catch {
      box.style.display = 'none';
    }
  }

  function applyMiniModeUI() {
    const lp = document.getElementById('lyricsplayerblock');
    if (!lp) return;

    const mini = isMiniMode();
    if (mini) lp.classList.add('mini-mode'); else lp.classList.remove('mini-mode');

    // Закрепляем сверху при мини-режиме
    if (mini) ensurePinnedTop(lp);

    // Скрываем лирику и фон-анимацию в мини (с возвращением)
    try {
      if (mini) {
        if (!window.__wasMini) window.__wasMini = true;
        if (window.__savedLyricsModeForMini === null && window.lyricsViewMode !== 'hidden') window.__savedLyricsModeForMini = window.lyricsViewMode;
        if (window.lyricsViewMode !== 'hidden' && typeof window.applyLyricsViewMode === 'function') {
          window.lyricsViewMode = 'hidden';
          window.applyLyricsViewMode();
        }
        if (window.__savedAnimationForMini === null && window.animationEnabled === true) window.__savedAnimationForMini = true;
        if (window.animationEnabled === true && typeof window.applyAnimationState === 'function') window.applyAnimationState(false);
      } else {
        if (window.__wasMini) window.__wasMini = false;
        if (window.__savedLyricsModeForMini !== null && typeof window.applyLyricsViewMode === 'function') {
          window.lyricsViewMode = window.__savedLyricsModeForMini;
          window.__savedLyricsModeForMini = null;
          window.applyLyricsViewMode();
        }
        if (window.__savedAnimationForMini !== null && typeof window.applyAnimationState === 'function') {
          window.applyAnimationState(!!window.__savedAnimationForMini);
          window.__savedAnimationForMini = null;
        }
      }
    } catch {}

    // "Далее" показывает/обновляет данные; якорь уже создаётся в renderLyricsBlock
    ensureNextUpLabel();
    updateMiniNowHeader();
    updateNextUpLabel();
  }

  function toggleLikePlayingFromMini(e) {
    try { if (e && e.stopPropagation) e.stopPropagation(); } catch {}
    if (typeof window.toggleLikePlaying === 'function') {
      window.toggleLikePlaying();
    }
    updateMiniNowHeader();
    updateNextUpLabel();
  }

  async function openPlayingAlbumFromMini(e) {
    try {
      if (e && e.target && e.target.id === 'mini-now-star') return;
    } catch {}

    // Открыть "Избранное" и проскроллить к текущему
    if (window.playingAlbumKey === window.SPECIAL_FAVORITES_KEY) {
      if (typeof window.openFavoritesView === 'function') window.openFavoritesView();
      const idx = computeCurrentIndex();
      const cur = Array.isArray(window.favoritesRefsModel) ? window.favoritesRefsModel[idx] : null;
      if (cur) {
        setTimeout(() => document.getElementById(`fav_${cur.__a}_${cur.__t}`)?.scrollIntoView({ behavior: 'smooth', block: 'center' }), 250);
      }
      return;
    }

    // Если уже в играющем альбоме — ничего не делаем
    if (!window.playingAlbumKey || window.currentAlbumKey === window.playingAlbumKey) return;

    // 1) Курсор до загрузки
    const idx = computeCurrentIndex();
    if (idx >= 0) window.currentTrack = idx;

    // 2) Переключить селект и загрузить альбом
    const sel = document.getElementById('album-select');
    if (sel) sel.value = window.playingAlbumKey;
    if (typeof window.loadAlbumByKey === 'function') {
      await window.loadAlbumByKey(window.playingAlbumKey);
    }

    // 3) Перенести блок плеера под строку и проскроллить
    setTimeout(() => {
      try {
        const row = document.getElementById(`trk${computeCurrentIndex()}`);
        const lp = document.getElementById('lyricsplayerblock');
        if (row && lp) {
          if (row.nextSibling) row.parentNode.insertBefore(lp, row.nextSibling);
          else row.parentNode.appendChild(lp);
        }
        if (row) row.scrollIntoView({ behavior: 'smooth', block: 'center' });
      } catch {}
    }, 200);
  }

  // Публичный API
  const MiniUI = {
    applyMiniModeUI,
    updateMiniNowHeader,
    updateNextUpLabel,
    toggleLikePlayingFromMini,
    openPlayingAlbumFromMini
  };

  // Экспорт в глобальную область
  window.MiniUI = MiniUI;

})();

//=================================================
// FILE: /scripts/ui/modals.js
// scripts/ui/modals.js (ESM)
// Универсальная система управления модальными окнами.

(function(){
  function toggleModal(modalId, show) {
    const modal = document.getElementById(modalId);
    if (!modal) return;
    
    const doShow = show === undefined ? !modal.classList.contains('active') : show;
    modal.classList.toggle('active', doShow);
    
    // Закрытие по клику на фон
    if(doShow) {
        modal.addEventListener('click', e => {
            if(e.target === modal) {
                toggleModal(modalId, false);
            }
        });
    }
  }

  // Экспорт
  window.toggleModal = toggleModal;
})();

//=================================================
// FILE: /scripts/ui/notify.js
// scripts/ui/notify.js
// Единый модуль уведомлений (тосты) с очередью показа.
// Глобальный API: window.NotificationSystem.{show,info,success,warning,error,offline}

(function initNotificationSystem() {
  if (window.NotificationSystem && window.NotificationSystem.__unified) return;

  const queue = [];
  let isShowing = false;

  const TYPE_DEFAULT_DURATION = {
    info: 3000,
    success: 3000,
    warning: 4000,
    error: 5000,
    offline: 3000
  };

  const EMOJI = {
    info: 'ℹ️',
    success: '✅',
    error: '❌',
    warning: '⚠️',
    offline: '🌐'
  };

  function toNumber(n, fallback) {
    const x = Number(n);
    return Number.isFinite(x) && x > 0 ? x : fallback;
  }

  function normalizeShowArgs(message, type, duration) {
    // Поддержка вызова show(options)
    if (typeof message === 'object' && message !== null) {
      const o = message;
      const t = String(o.type || 'info');
      const d = toNumber(o.duration, TYPE_DEFAULT_DURATION[t] || 3000);
      return { message: String(o.message || ''), type: t, duration: d };
    }
    const t = String(type || 'info');
    const d = toNumber(duration, TYPE_DEFAULT_DURATION[t] || 3000);
    return { message: String(message || ''), type: t, duration: d };
  }

  async function processQueue() {
    if (isShowing) return;
    isShowing = true;

    while (queue.length > 0) {
      const { message, type, duration } = queue.shift();

      const toast = document.createElement('div');
      toast.className = `toast toast-${type}`;
      toast.innerHTML = `
        <div class="toast-content">
          <span class="toast-emoji" aria-hidden="true">${EMOJI[type] || ''}</span>
          <span class="toast-text">${message}</span>
        </div>
      `;

      document.body.appendChild(toast);
      // Плавное появление
      await new Promise(r => setTimeout(r, 10));
      toast.classList.add('show');

      // Ожидание видимости
      await new Promise(r => setTimeout(r, duration));

      // Скрытие и удаление
      toast.classList.remove('show');
      await new Promise(r => setTimeout(r, 300));
      try { toast.remove(); } catch {}
    }

    isShowing = false;
  }

  function enqueueShow(message, type = 'info', duration) {
    const { message: msg, type: t, duration: dur } = normalizeShowArgs(message, type, duration);
    queue.push({ message: msg, type: t, duration: dur });
    if (!isShowing) processQueue().catch(() => { isShowing = false; });
  }

  const NotificationSystem = {
    __unified: true,
    show: enqueueShow,
    info(msg, duration)    { enqueueShow(msg, 'info', duration); },
    success(msg, duration) { enqueueShow(msg, 'success', duration); },
    warning(msg, duration) { enqueueShow(msg, 'warning', duration); },
    error(msg, duration)   { enqueueShow(msg, 'error', duration); },
    offline(msg, duration) { enqueueShow(msg, 'offline', duration); }
  };

  window.NotificationSystem = NotificationSystem;
})();


//=================================================
// FILE: /scripts/ui/sleep.js


//=================================================
// FILE: /scripts/ui/sysinfo.js
// scripts/ui/sysinfo.js (ESM)
// Кнопка «О СИСТЕМЕ»: запрашивает у SW инфо и показывает модал.

function formatBytes(n) {
  if (!Number.isFinite(n) || n <= 0) return '0 B';
  const u = ['B','KB','MB','GB']; let i = 0;
  while (n >= 1024 && i < u.length - 1) { n /= 1024; i++; }
  return `${n.toFixed(1)} ${u[i]}`;
}

function buildModal(info) {
  const m = document.createElement('div');
  m.className = 'modal-bg active';
  const cfg = info?.config || {};
  const net = info?.net || {};
  const media = info?.media || {};
  const offline = info?.offline || {};
  const ver = info?.version || '(нет)';
  const prof = offline?.profile || info?.profile || 'default';

  m.innerHTML = `
    <div class="modal-feedback" style="max-width: 520px;">
      <button class="bigclose" onclick="this.closest('.modal-bg').remove()" title="Закрыть">
        <svg viewBox="0 0 48 48"><line x1="12" y1="12" x2="36" y2="36" stroke="currentColor" stroke-width="6" stroke-linecap="round"/><line x1="36" y1="12" x2="12" y2="36" stroke="currentColor" stroke-width="6" stroke-linecap="round"/></svg>
      </button>
      <div style="font-weight:800; font-size:1.1em; margin-bottom:10px;">О системе</div>
      <div style="font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:.95em; line-height:1.5;">
        <div><b>SW версия:</b> ${ver}</div>
        <div><b>Оффлайн профиль:</b> ${prof}</div>
        <div><b>Оффлайн файлов:</b> ${offline?.count ?? 0}</div>
        <div><b>MediaCache:</b> ${formatBytes(media?.totalBytes || 0)} (${media?.items || 0} объектов)</div>
        <hr style="border-color:#333; margin:8px 0;">
        <div><b>Сеть:</b> saveData=${net?.saveData ? '1' : '0'}, downlink=${net?.downlink ?? '—'}Mb/s, type=${net?.effectiveType ?? '—'}</div>
        <hr style="border-color:#333; margin:8px 0;">
        <div><b>SW лимиты:</b> mediaMax=${cfg?.mediaMaxCacheMB ?? '-'}MB; nonRange=${cfg?.nonRangeMaxStoreMB ?? '-'}MB; slow=${cfg?.nonRangeMaxStoreMBSlow ?? '-'}MB; revalidateDays=${cfg?.revalidateDays ?? '-'}</div>
      </div>
    </div>`;
  return m;
}

function showSystemInfoModal(info) {
  const m = buildModal(info);
  document.body.appendChild(m);
}

function requestSystemInfo() {
  if (!('serviceWorker' in navigator)) {
    window.NotificationSystem && window.NotificationSystem.warning('Service Worker недоступен');
    return;
  }
  const send = () => {
    try {
      const ctl = navigator.serviceWorker.controller;
      if (ctl) ctl.postMessage({ type: 'GET_SW_INFO' });
    } catch {}
  };
  // Ответ обработаем через message
  send();
}

function showSystemInfo() {
  requestSystemInfo();
}

// Поймаем ответ
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.addEventListener('message', (ev) => {
    const msg = ev.data || {};
    if (msg.type === 'SW_INFO' && msg.info) {
      showSystemInfoModal(msg.info);
    }
  });
}

// Показать кнопку при наличии клавиатуры (как для hotkeys)
(function bootstrap() {
  const btn = document.getElementById('sysinfo-btn');
  if (!btn) return;
  try {
    const hasKeyboard = window.hasKeyboard ? window.hasKeyboard() : true;
    btn.style.display = hasKeyboard ? 'block' : 'none';
  } catch {
    btn.style.display = 'block';
  }
})();

// Экспорт глобали для onclick
window.showSystemInfo = showSystemInfo;

//=================================================
// FILE: /albums/gallery/news/news-01-baner.html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="color-scheme" content="dark">
  <title>Новости — Голос Души на Яндекс Музыке</title>
  <style>
    :root{
      --bg-0: #0b0e15;     /* базовый фон */
      --bg-1: #0f1422;     /* панель/карта */
      --bg-2: #0a0d17;     /* внутренний фон */
      --text: #e8ecf6;     /* основной текст */
      --muted: #a9b3c7;    /* вторичный */
      --accent-1: #4aa3ff; /* акцент границы */
      --accent-2: #7be3ff; /* акцент границы 2 */
      --shadow: 0 12px 28px rgba(0,0,0,0.45), 0 3px 10px rgba(0,0,0,0.35);
      --radius: 16px;
      --radius-inner: 12px;
    }
    html,body{
      height:100%;
      margin:0;
      background: radial-gradient(120% 120% at 10% 10%, #111827 0%, #0b0e15 45%, #070a12 100%);
      color: var(--text);
      font: 500 16px system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    }
    .wrap{
      position:relative;
      height:100%;
      width:100%;
      display:grid;
      place-items:center;
      padding:10px;
      box-sizing:border-box;
    }
    /* Внешняя «градиентная рамка» */
    .frame{
      position:relative;
      width:100%;
      height:100%;
      max-width:900px;
      max-height:900px;
      border-radius: var(--radius);
      padding:1px; /* толщина рамки */
      background: linear-gradient(135deg, rgba(74,163,255,0.85), rgba(123,227,255,0.85));
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card{
      position:relative;
      width:100%;
      height:100%;
      border-radius: calc(var(--radius) - 1px);
      background:
        radial-gradient(140% 120% at 80% 0%, rgba(27,41,72,0.55), transparent 60%),
        radial-gradient(120% 140% at 0% 100%, rgba(18,30,58,0.6), transparent 55%),
        var(--bg-1);
      display:flex;
      flex-direction:column;
      gap:14px;
      padding:16px;
      box-sizing:border-box;
      border: 1px solid rgba(255,255,255,0.06);
    }
    .badge{
      align-self:flex-start;
      font-size:12px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color: var(--muted);
      padding:6px 10px;
      border-radius:999px;
      background: linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
      border:1px solid rgba(255,255,255,0.08);
      backdrop-filter: blur(2px);
    }
    .title{
      font-weight:700;
      font-size: clamp(18px, 3vw, 24px);
      line-height:1.25;
      margin:0 4px;
      color: var(--text);
      text-shadow: 0 1px 0 rgba(0,0,0,0.25);
    }
    .subtitle{
      margin: -6px 4px 2px;
      color: var(--muted);
      font-size: 14px;
    }

    /* Квадратная зона плеера */
    .embed{
      position:relative;
      margin-top: 4px;
      width:100%;
      flex: 1 1 auto;
      aspect-ratio: 1 / 1; /* удерживаем квадрат */
      border-radius: var(--radius-inner);
      background:
        radial-gradient(120% 140% at 50% 50%, rgba(10,13,23,0.8), rgba(6,8,15,0.92)),
        var(--bg-2);
      border:1px solid rgba(255,255,255,0.07);
      overflow:hidden;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03), 0 10px 24px rgba(0,0,0,0.45);
    }
    /* Делаем сам iframe Я.Музыки резиновым на весь квадрат */
    .embed iframe{
      position:absolute;
      inset:0;
      width:100% !important;
      height:100% !important;
      border:0 !important;
      display:block;
      background: transparent;
    }

    /* Низ карточки */
    .footer{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-top: 4px;
    }
    .hint{
      color: var(--muted);
      font-size: 12px;
      opacity: .9;
    }
    .cta{
      padding:8px 12px;
      border-radius:10px;
      background: linear-gradient(180deg, rgba(255,255,255,0.07), rgba(255,255,255,0.03));
      border: 1px solid rgba(255,255,255,0.10);
      color: var(--text);
      text-decoration:none;
      font-weight:600;
      transition: transform .12s ease, background .2s ease;
    }
    .cta:hover{ transform: translateY(-1px); }
    .cta:active{ transform: translateY(0); }

    /* На очень маленьких высотах слегка уменьшаем отступы */
    @media (max-height: 420px){
      .card{ padding:12px; gap:10px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="frame">
      <section class="card" role="region" aria-label="Новостной баннер — Голос Души">
        <div class="badge">Новости</div>
        <h1 class="title">«Голос Души» — уже на Яндекс&nbsp;Музыке</h1>
        <p class="subtitle">Слушайте новый альбом группы «Витрина Разбита»</p>

        <div class="embed" role="group" aria-label="Плеер Яндекс Музыки">
          <!-- ВАШ ВСТАВЛЕННЫЙ КОД Яндекс Музыки (адаптивный на весь квадрат) -->
          <iframe
            frameborder="0"
            allow="clipboard-write"
            style="border:none;width:614px;height:614px;"
            width="614"
            height="614"
            src="https://music.yandex.ru/iframe/album/38188979">
              Слушайте <a href="https://music.yandex.ru/album/38188979?utm_source=web&utm_medium=copy_link">Голос Души</a> — <a href="https://music.yandex.ru/artist/24739002">Витрина Разбита</a> на Яндекс Музыке
          </iframe>
        </div>

        <div class="footer">
          <div class="hint">Совет: нажмите «поделиться» в плеере, чтобы рассказать друзьям</div>
          <a class="cta" href="https://music.yandex.ru/album/38188979?utm_source=web&utm_medium=copy_link" target="_blank" rel="noopener">Открыть альбом</a>
        </div>
      </section>
    </div>
  </div>
</body>
</html>

//=================================================
// FILE: /generate-context.js
/* eslint-disable no-console */
"use strict";

/**
 * generate-context.js
 *
 * Генератор .meta/project-full.txt и .meta/project-adaptive.txt
 * Требования (выполнены):
 * 1) В начале — блок «ПРАВИЛА ДЛЯ НЕЙРОСЕТЕЙ», затем мета‑блок с названием/URL репозитория и пометкой про GitHub.
 * 2) СТРУКТУРА ПРОЕКТА — ПОЛНОЕ дерево ВСЕХ файлов (включая assets/), но без .git/** и .meta/**.
 *    Дополнительно защищаемся от самовключения результирующих файлов.
 * 3) После дерева — секция «ФАЙЛЫ»: только текстовые файлы, по приоритетам (critical → high → medium → low),
 *    каждый файл выводится целиком. Здесь assets/** исключаем (по вашему требованию), .meta/** тоже исключаем.
 * 4) НЕТ блока «Критичные логи».
 * 5) Adaptive-режим ограничивает общий объём строк параметром --max-lines (по умолчанию 20000).
 *
 * Запуск:
 *   node generate-context.js --mode=both --max-lines=20000
 *   node generate-context.js --mode=full
 *   node generate-context.js --mode=adaptive --out-dir=.meta
 *
 * Аргументы:
 *   --mode=both|full|adaptive
 *   --max-lines=ЧИСЛО           // только для adaptive
 *   --out-dir=ПУТЬ              // по умолчанию .meta
 *   --root=ПУТЬ                 // корень проекта (по умолчанию текущая папка)
 */

const fs = require("fs");
const path = require("path");

// -------------------- CLI --------------------
const argv = Object.fromEntries(
  process.argv.slice(2).map(a => {
    const [k, ...r] = a.replace(/^--/, "").split("=");
    return [k, r.join("=") === "" ? true : r.join("=")];
  })
);

const ROOT     = path.resolve(argv.root || __dirname);
const META_DIR = path.resolve(argv["out-dir"] || path.join(ROOT, ".meta"));
const MODE     = (argv.mode || "both").toLowerCase(); // full | adaptive | both
const MAX_LINES = Number(argv["max-lines"] || 20000);

// Гарантируем наличие .meta
if (!fs.existsSync(META_DIR)) fs.mkdirSync(META_DIR, { recursive: true });

const FULL_FILE    = path.join(META_DIR, "project-full.txt");
const ADAPTIVE_FILE= path.join(META_DIR, "project-adaptive.txt");

// Относительные пути к self-файлам (для защиты от самовключения)
const SELF_FULL_REL  = toUnix(path.relative(ROOT, FULL_FILE));
const SELF_ADAPT_REL = toUnix(path.relative(ROOT, ADAPTIVE_FILE));

// -------------------- Настройки --------------------

// Текстовые расширения, содержимое которых включаем в секцию «ФАЙЛЫ»
const TEXT_EXTS = new Set([
  ".html",".htm",".css",".js",".mjs",".cjs",".ts",".tsx",
  ".json",".webmanifest",".md",".txt",".yml",".yaml"
]);

/**
 * Исключения для СЕКЦИИ «ФАЙЛЫ» (только к листингу контента, НЕ к дереву):
 * - По требованию исключаем .meta/** и assets/** (не попадут в контент),
 * - Исключаем служебные каталоги.
 */
const EXCLUDE_FILES_PATTERNS = [
  "node_modules/**",
  ".git/**",
  ".meta/**",
  "assets/**",
  ".next/**","dist/**","build/**","out/**","coverage/**",
  ".cache/**",".vscode/**",".idea/**",".husky/**",
  "**/*.log",".DS_Store"
].map(globToRegExp);

/**
 * Исключения ТОЛЬКО для СТРУКТУРЫ ДЕРЕВА:
 * - По требованию показываем ВСЕ файлы, включая assets/**.
 * - Исключаем только .git/**, .meta/** и служебные каталоги (node_modules и т.п.),
 *   плюс защищаемся от самовключения итоговых файлов.
 */
const EXCLUDE_TREE_PATTERNS = [
  "node_modules/**",
  ".git/**",
  ".meta/**",
  ".next/**","dist/**","build/**","out/**","coverage/**",
  ".cache/**",".vscode/**",".idea/**",".husky/**",
  "**/*.log",".DS_Store"
].map(globToRegExp);

// Приоритеты для секции «ФАЙЛЫ»
const PRIORITY = {
  critical: [
    /^index\.html?$/i,
    /^service-worker\.js$/i,
    /^manifest\.json$/i,
    /^albums\.json$/i,
    /^custom\.json$/i,
    /^news\.html?$/i,
    /^generate-index\.(js|mjs|cjs)$/i,
    /^albums\/gallery\/[^/]+\/index\.json$/i,
    /^\.github\/workflows\/.*\.ya?ml$/i
  ],
  high: [
    /^AudioController\.(js|mjs|cjs|ts)$/i,
    /^GlobalState\.(js|mjs|cjs|ts)$/i,
    /^scripts\/.*\.(mjs|js|ts)$/i,
    /^performance\/.*\.(js|ts)$/i,
    /^.*\.(ya?ml)$/i
  ],
  medium: [
    /^.*\.(js|mjs|cjs|ts|tsx|json|html?|css)$/i
  ],
};

// -------------------- Утилиты --------------------
function toUnix(p) {
  return String(p).replace(/\\/g, "/");
}
function globToRegExp(pat) {
  const esc = pat
    .replace(/[.+^${}()|[\]\\]/g, "\\$")
    .replace(/\*\*/g, "___GLOBSTAR___")
    .replace(/\*/g, "[^/]*")
    .replace(/___GLOBSTAR___/g, ".*");
  return new RegExp("^" + esc + "$");
}
function isTextFile(rel) {
  return TEXT_EXTS.has(path.extname(rel).toLowerCase());
}
function readText(rel) {
  try { return fs.readFileSync(path.join(ROOT, rel), "utf8"); }
  catch (e) { return `// read error: ${e.message}`; }
}
function countLines(s) {
  return (s.match(/\n/g) || []).length + (s.length ? 1 : 0);
}

// Исключения для секции «ФАЙЛЫ»
function isExcludedForFiles(rel) {
  const u = toUnix(rel);
  if (!u) return true;
  if (u === SELF_FULL_REL || u === SELF_ADAPT_REL) return true; // защита от самовключения
  return EXCLUDE_FILES_PATTERNS.some(re => re.test(u));
}
// Исключения для дерева
function isExcludedForTree(rel) {
  const u = toUnix(rel);
  if (!u) return true;
  if (u === SELF_FULL_REL || u === SELF_ADAPT_REL) return true; // защита от самовключения
  return EXCLUDE_TREE_PATTERNS.some(re => re.test(u));
}

// -------------------- Сканирование --------------------
function listAllEntries(includeFiles = true, forTree = false) {
  const res = [];
  const stack = [ROOT];

  while (stack.length) {
    const dir = stack.pop();
    let entries = [];
    try { entries = fs.readdirSync(dir, { withFileTypes: true }); } catch { continue; }

    for (const e of entries) {
      const full = path.join(dir, e.name);
      const rel = toUnix(path.relative(ROOT, full)) || ".";

      // Выбор правил исключения: для дерева — свои, для контента — свои
      const excluded = forTree ? isExcludedForTree(rel) : isExcludedForFiles(rel);
      if (excluded) continue;

      if (e.isDirectory()) {
        res.push({ rel, full, dir: true });
        stack.push(full);
      } else if (e.isFile() && includeFiles) {
        res.push({ rel, full, dir: false });
      }
    }
  }

  // Папки сверху, затем файлы; внутри — по алфавиту
  res.sort((a, b) => (a.dir !== b.dir ? (a.dir ? -1 : 1) : a.rel.localeCompare(b.rel)));
  return res;
}

function listTextFilesForContent() {
  return listAllEntries(true, /*forTree*/ false)
    .filter(e => !e.dir && isTextFile(e.rel))
    .map(e => e.rel);
}

// -------------------- Репозиторий --------------------
function readRepoMeta() {
  let url = "";
  try {
    const cfg = path.join(ROOT, ".git", "config");
    if (fs.existsSync(cfg)) {
      const raw = fs.readFileSync(cfg, "utf8");
      const m = raw.match(/url\s*=\s*(.+)\n/);
      if (m) url = m[1].trim();
    }
  } catch {}
  return {
    name: path.basename(ROOT),
    url: url || "(URL репозитория не обнаружен; укажите в .git/config)",
    madeWith: "Проект делается и обслуживается средствами https://github.com/ (GitHub Pages + GitHub Actions).",
  };
}

// -------------------- Блоки заголовка --------------------
function rulesBlock() {
  return [
    "ПРАВИЛА ДЛЯ НЕЙРОСЕТЕЙ (важно для качества ответов):",
    "- Язык ответов: по умолчанию RU. Английский — если явно попросят или в именах/терминах.",
    "- Всегда начинай с полного и детального анализа всего приложения.",
    "- Всегда указывай точные пути файлов при ссылках (например, src/app/(main)/timeline/page.tsx).",
    "- Любой код выводи ТОЛЬКО в тройных бэктиках с указанием языка, например:",
    "  ```ts",
    "  export function x() {}",
    "  ```",
    "- Не используй тяжелое форматирование. Разрешены: списки, короткие таблицы.",
    "- Если требуются изменения в файле — показывай минимальный патч (unified diff) или целиком обновлённый файл (не смешивать).",
    "- Не выдумывай зависимости и API. Если данных нет — явно скажи «нужно уточнение».",
    "- Учитывай что я работаю через web интерфейс github.com и не возможности локально делать проект.",
    "- Стиль кода: TypeScript strict, ESM-импорты, 2 пробела.",
    "- НИКОГДА не генерируй весь файл project-full целиком; только блоки для замены со строгим указанием места.",
    "- Формат изменений: -> ФАЙЛ: путь -> НАЙТИ: [фрагмент дословно] -> ЗАМЕНИТЬ НА: [полный новый блок].",
    "- Если какой то файл приложения требует полной замены, то присылай именно этого файла полный и правильный (соответствующий моему проекту) файл который этого требует. ",
    "- Сохраняй комментарии, форматирование и импорт-структуру.",
    "- Если удаляем блок — укажи строку перед и строку после (из реального кода).",
    "- Всегда пиши краткое обоснование, что и почему делаем.",
    "- Очень важно! Прервать воспроизведение могут только кнопки Пауза, стоп и срабатывание таймера, при всех остальных сценариях какие бы не были плеер всегда играет и на всех устройствах, ничего другого его не может остановить или сбросить или отключить звук, вообще никакая другая функция - это базовое правило этого проигрывателя.",
    "- Всегда предлагай список дальнейших улучшений и критических ошибок если они встречаются во всей программе при анализе.",
    ""
  ].join("\n");
}

function metaBlock() {
  const m = readRepoMeta();
  return [
    `Название репозитория: ${m.name}`,
    `Адрес репозитория: ${m.url}`,
    "# ПОЛНЫЙ И ДЕТАЛЬНЫЙ АНАЛИЗ ПРИЛОЖЕНИЯ.",
    m.madeWith,
    ""
  ].join("\n");
}

// -------------------- СТРУКТУРА ПРОЕКТА (дерево) --------------------
function buildFullTree() {
  const lines = [];
  lines.push(path.basename(ROOT) + "/");

  function walk(dir, prefix = "") {
    let entries = [];
    try { entries = fs.readdirSync(dir, { withFileTypes: true }); } catch { return; }

    const visible = entries
      .filter(e => !isExcludedForTree(toUnix(path.relative(ROOT, path.join(dir, e.name)))))
      .sort((a, b) => (a.isDirectory() !== b.isDirectory() ? (a.isDirectory() ? -1 : 1) : a.name.localeCompare(b.name)));

    visible.forEach((e, i) => {
      const isLast = i === visible.length - 1;
      const branch = isLast ? "└── " : "├── ";
      lines.push(prefix + branch + e.name + (e.isDirectory() ? "/" : ""));
      if (e.isDirectory()) {
        walk(path.join(dir, e.name), prefix + (isLast ? "    " : "│   "));
      }
    });
  }

  walk(ROOT);
  return lines.join("\n") + "\n\n";
}

// -------------------- Секция «ФАЙЛЫ» --------------------
function getPriority(rel) {
  const u = toUnix(rel);
  for (const [lvl, rules] of Object.entries(PRIORITY)) {
    if (rules.some(re => re.test(u))) return lvl;
  }
  return "low";
}

function groupFilesByPriority() {
  const all = listTextFilesForContent(); // уже исключены assets/.meta и прочие по EXCLUDE_FILES_PATTERNS
  return {
    critical: all.filter(f => getPriority(f) === "critical"),
    high:     all.filter(f => getPriority(f) === "high"),
    medium:   all.filter(f => getPriority(f) === "medium"),
    low:      all.filter(f => getPriority(f) === "low"),
  };
}

function fileBlock(rel) {
  return [
    "//=================================================",
    `// FILE: /${toUnix(rel)}`,
    readText(rel),
    ""
  ].join("\n");
}

// -------------------- Заголовок отчёта --------------------
function headerBlock() {
  const now = new Date().toISOString().replace("T"," ").slice(0,19) + " UTC";
  return [
    rulesBlock(),
    metaBlock(),
    "СТРУКТУРА ПРОЕКТА:",
    buildFullTree(),
    `Сгенерировано: ${now}`,
    ""
  ].join("\n");
}

// -------------------- Генераторы --------------------
function generateFull() {
  let out = headerBlock();

  const groups = groupFilesByPriority();
  const order = ["critical", "high", "medium", "low"];
  for (const lvl of order) {
    for (const f of groups[lvl]) {
      out += fileBlock(f);
    }
  }

  // БЕЗ блока «Критичные логи»
  return out;
}

function generateAdaptive() {
  let out = headerBlock();
  let cur = countLines(out);
  const max = MAX_LINES;

  const groups = groupFilesByPriority();
  const order = ["critical", "high", "medium"]; // low пропускаем в adaptive чаще всего

  for (const lvl of order) {
    for (const f of groups[lvl]) {
      const block = fileBlock(f);
      const L = countLines(block);
      if (cur + L > max) {
        out += "\n// ... (truncate)\n";
        return out;
      }
      out += block; cur += L;
    }
  }

  // БЕЗ блока «Критичные логи»
  return out;
}

// -------------------- MAIN --------------------
function main() {
  if (MODE === "full" || MODE === "both") {
    fs.writeFileSync(FULL_FILE, generateFull(), "utf8");
    console.log(`✅ ${FULL_FILE}`);
  }
  if (MODE === "adaptive" || MODE === "both") {
    fs.writeFileSync(ADAPTIVE_FILE, generateAdaptive(), "utf8");
    console.log(`✅ ${ADAPTIVE_FILE}`);
  }
}

try { main(); } catch (e) { console.error("❌", e); process.exit(1); }

//=================================================
// FILE: /news/news.json
{
  "items": [
    {
      "id": "2025-11-01-release",
      "title": "Новый релиз — Между Злом и Добром",
      "date": "2025-11-01",
      "text": "Доступен новый альбом. Слушайте онлайн и офлайн в нашем приложении.",
      "image": "img/logo.png",
      "tags": ["релиз", "альбом"]
    },
    {
      "id": "2025-10-20-video",
      "title": "Клип на трек «Отражение»",
      "date": "2025-10-20",
      "embedUrl": "https://www.youtube.com/embed/dQw4w9WgXcQ",
      "tags": ["клип", "видео"]
    },
    {
      "id": "2025-10-05-tour",
      "title": "Тур: зимние концерты",
      "date": "2025-10-05",
      "text": "Актуальное расписание — в наших соцсетях.",
      "tags": ["концерты"]
    }
  ]
}

//=================================================
// FILE: /src/PlayerCore.js
// src/PlayerCore.js (ESM)
// Ядро воспроизведения на Howler.js для vi3na1bita-music.
// Управляет: плейлистом, play/pause/stop/prev/next, repeat/shuffle/favoritesOnly,
// громкостью/позициями, автопереходом, MediaSession и "тикером" времени.

export class PlayerCore {
  constructor(events = {}, options = {}) {
    this.playlist = [];
    this.index = 0;
    this.howl = null;
    this.events = { ...events };
    this.repeat = false;
    this.shuffle = false;
    this.favoritesOnly = false;
    this.favorites = [];
    this.shuffled = [];
    this._ticker = null;
    this._tickIntervalMs = Math.max(100, options.tickIntervalMs || 250);
    this._isPaused = true;
    this._albumArtist = '';
    this._albumTitle = '';
    this._albumCover = '';
    // Sleep timer
    this._sleepTimerId = null;
    this._sleepTargetTs = 0;

    this._installMediaSessionHandlersOnce();
  }

  setPlaylist(tracks, startIndex = 0, albumMeta = {}) {
    this.stop();
    this.playlist = Array.isArray(tracks) ? tracks.slice() : [];
    this.index = Math.max(0, Math.min(this.playlist.length - 1, startIndex || 0));
    this._albumArtist = albumMeta.artist || (tracks && tracks[0] && tracks[0].artist) || '';
    this._albumTitle  = albumMeta.album  || (tracks && tracks[0] && tracks[0].album)  || '';
    this._albumCover  = albumMeta.cover  || (tracks && tracks[0] && tracks[0].cover)  || '';
    this._syncShuffle(true);
    const t = this.getCurrentTrack();
    this._fire('onTrackChange', t, this.index);
  }

  on(events) { this.events = { ...this.events, ...events }; }
  setEvents(events) { this.events = { ...events }; }

  setRepeat(v) { this.repeat = !!v; }
  setShuffle(v) { this.shuffle = !!v; this._syncShuffle(true); }
  setFavoritesOnly(v, favorites = []) {
    this.favoritesOnly = !!v;
    this.favorites = Array.isArray(favorites) ? favorites.slice() : [];
    this._syncShuffle(true);
  }

  play(index) {
    if (typeof index === 'number') this.index = this._clampIndex(index);
    if (!this.playlist.length) return;

    // Если Howl уже есть и играет тот же трек — просто возобновляем
    if (this.howl && this._isPaused && this.howl._src === (this.playlist[this.index]?.src || '')) {
      this.howl.play();
      return;
    }

    this._stopHowl();
    const tr = this.getCurrentTrack();
    if (!tr || !tr.src) return;

    this.howl = new Howl({
      src: [tr.src],
      html5: true,
      onend: () => {
        if (this.repeat) { this.play(); return; }
        this.next();
        this._fire('onEnd', tr, this.index);
      },
      onplay: () => {
        this._isPaused = false;
        this._fire('onPlay', tr, this.index);
        this._fire('onTrackChange', tr, this.index);
        this._updateMediaSessionMeta();
        this._startTicker();
      },
      onpause: () => { this._isPaused = true; this._fire('onPause', tr, this.index); this._stopTicker(); },
      onstop:  () => { this._isPaused = true; this._fire('onStop',  tr, this.index); this._stopTicker(); },
      onplayerror: (_, err) => {
        console.warn('Howler play error:', err);
        // Попытка разблокировать аудио контекст
        try { this.howl.once('unlock', () => { try { this.howl.play(); } catch {} }); } catch {}
      },
      onloaderror: (_, err) => {
        console.warn('Howler load error:', err);
        // Можно добавить логику для пропуска трека
      }
    });

    try {
      const saved = parseFloat(localStorage.getItem('playerVolume'));
      if (Number.isFinite(saved)) this.setVolume(saved);
    } catch {}
    this.howl.play();
  }

  pause() { if (this.howl && !this._isPaused) this.howl.pause(); }
  stop()  { this._stopHowl(); this._isPaused = true; this._fire('onStop', this.getCurrentTrack(), this.index); }

  next() {
    const n = this._nextIndex();
    if (n < 0) { this.stop(); return; }
    this.index = n;
    this.play();
  }
  prev() {
    const p = this._prevIndex();
    if (p < 0) { this.stop(); return; }
    this.index = p;
    this.play();
  }

  setVolume(v) {
    const vol = Math.max(0, Math.min(1, Number(v)));
    if (this.howl) this.howl.volume(vol);
    else if (typeof Howler !== 'undefined') Howler.volume(vol);
  }
  getVolume() {
    if (this.howl) return this.howl.volume();
    if (typeof Howler !== 'undefined') return Howler.volume();
    return 1;
  }

  seek(sec) {
    if (!this.howl) return;
    if (typeof sec === 'number') this.howl.seek(Math.max(0, sec));
    else return Number(this.howl.seek()) || 0;
  }
  getSeek() { return this.seek(); }
  getDuration() { return this.howl ? (this.howl.duration() || 0) : 0; }

  getNextIndex() {
    return this._nextIndex();
  }

  getPlaylistSnapshot() {
    return (this.playlist || []).map(t => ({
      title: t?.title || '',
      artist: t?.artist || this._albumArtist || '',
      album: t?.album || this._albumTitle || '',
      cover: t?.cover || this._albumCover || '',
      lyrics: t?.lyrics || '',
      src: t?.src || '',
      fulltext: t?.fulltext || ''
    }));
  }

  isPlaying() { return !!this.howl && !this._isPaused; }
  getIndex() { return this.index; }
  getCurrentTrack() {
    if (!this.playlist.length) return null;
    return this.playlist[this.index] || null;
  }

  destroy() {
    this.stop();
    this._stopTicker();
    this.playlist = [];
    this.events = {};
  }

  _clampIndex(i) { return Math.max(0, Math.min(this.playlist.length - 1, i)); }
  _fire(name, ...args) { try { const fn = this.events && this.events[name]; if (typeof fn === 'function') fn(...args); } catch {} }

  _stopHowl() {
    if (this.howl) { try { this.howl.stop(); this.howl.unload(); } catch {} this.howl = null; }
  }

  _filteredIndices() {
    if (!this.playlist.length) return [];
    if (this.favoritesOnly && this.favorites.length) {
      return this.favorites.filter(i => Number.isInteger(i) && i >= 0 && i < this.playlist.length);
    }
    return this.playlist.map((_, i) => i);
  }
  _syncShuffle(force = false) {
    if (!this.shuffle) { this.shuffled = []; return; }
    const base = this._filteredIndices();

    // Если уже есть валидная последовательность и она подходит — не пересоздаём без нужды.
    if (!force && Array.isArray(this.shuffled) &&
        this.shuffled.length === base.length &&
        this.shuffled.includes(this.index)) {
      return;
    }

    const arr = base.slice();
    for (let j = arr.length - 1; j > 0; j--) {
      const k = Math.floor(Math.random() * (j + 1));
      [arr[j], arr[k]] = [arr[k], arr[j]];
    }
    const i = arr.indexOf(this.index);
    if (i > 0) { arr.splice(i, 1); arr.unshift(this.index); }
    this.shuffled = arr;
  }
  _displayList() {
    const base = this._filteredIndices();
    if (this.shuffle && this.shuffled.length) return this.shuffled.slice();
    return base;
  }
  _nextIndex() {
    const arr = this._displayList();
    if (!arr.length) return -1;
    const pos = arr.indexOf(this.index);
    const nextIdx = (pos + 1) % arr.length;
    return arr[nextIdx];
  }
  _prevIndex() {
    const arr = this._displayList();
    if (!arr.length) return -1;
    const pos = arr.indexOf(this.index);
    const prevIdx = (pos - 1 + arr.length) % arr.length;
    return arr[prevIdx];
  }

  _startTicker() {
    if (this._ticker) return;
    this._ticker = setInterval(() => {
      try {
        if (!this.isPlaying()) return;
        const pos = this.getSeek() || 0;
        const dur = this.getDuration() || 0;
        const fn = this.events && this.events.onTick;
        if (typeof fn === 'function') fn(pos, dur);
      } catch {}
    }, this._tickIntervalMs);
  }
  _stopTicker() {
    if (this._ticker) { clearInterval(this._ticker); this._ticker = null; }
  }

  setSleepTimer(ms) {
    try { this.clearSleepTimer(); } catch {}
    const n = Number(ms);
    if (!Number.isFinite(n) || n <= 0) return;
    this._sleepTargetTs = Date.now() + n;
    this._sleepTimerId = setTimeout(() => {
      this._sleepTimerId = null;
      this._sleepTargetTs = 0;
      try {
        if (this.howl && !this._isPaused) this.howl.pause();
      } catch {}
      this._fire('onSleepTriggered', this.getCurrentTrack(), this.index);
    }, n);
  }
  clearSleepTimer() {
    if (this._sleepTimerId) {
      try { clearTimeout(this._sleepTimerId); } catch {}
      this._sleepTimerId = null;
    }
    this._sleepTargetTs = 0;
  }
  getSleepTimerTarget() {
    return this._sleepTargetTs || 0;
  }

  _updateMediaSessionMeta() {
    if (!('mediaSession' in navigator)) return;
    const t = this.getCurrentTrack();
    if (!t) return;
    try {
      navigator.mediaSession.metadata = new window.MediaMetadata({
        title: t.title || '',
        artist: t.artist || this._albumArtist || '',
        album: t.album || this._albumTitle || '',
        artwork: (t.cover || this._albumCover) ? [
          { src: t.cover || this._albumCover, sizes: '512x512', type: 'image/png' }
        ] : []
      });
    } catch {}
    try {
      navigator.mediaSession.playbackState = this.isPlaying() ? 'playing' : 'paused';
      const self = this;
      navigator.mediaSession.setActionHandler('play',          () => self.play());
      navigator.mediaSession.setActionHandler('pause',         () => self.pause());
      navigator.mediaSession.setActionHandler('previoustrack', () => self.prev());
      navigator.mediaSession.setActionHandler('nexttrack',     () => self.next());
      navigator.mediaSession.setActionHandler('seekbackward',  (d) => self.seek((self.getSeek() || 0) - (d.seekOffset || 10)));
      navigator.mediaSession.setActionHandler('seekforward',   (d) => self.seek((self.getSeek() || 0) + (d.seekOffset || 10)));
      navigator.mediaSession.setActionHandler('seekto',        (d) => { if (typeof d.seekTime === 'number') self.seek(d.seekTime); });
      navigator.mediaSession.setActionHandler('stop',          () => self.stop());
    } catch {}
  }

  _installMediaSessionHandlersOnce() {
    if (!('mediaSession' in navigator) || window.__msInstalled) return;
    try {
      const self = this;
      navigator.mediaSession.setActionHandler('play', () => self.play());
      navigator.mediaSession.setActionHandler('pause', () => self.pause());
      navigator.mediaSession.setActionHandler('previoustrack', () => self.prev());
      navigator.mediaSession.setActionHandler('nexttrack', () => self.next());
      navigator.mediaSession.setActionHandler('seekbackward', (d) => self.seek((self.getSeek() || 0) - (d.seekOffset || 10)));
      navigator.mediaSession.setActionHandler('seekforward', (d) => self.seek((self.getSeek() || 0) + (d.seekOffset || 10)));
      navigator.mediaSession.setActionHandler('seekto', (d) => { if (typeof d.seekTime === 'number') self.seek(d.seekTime); });
      navigator.mediaSession.setActionHandler('stop', () => self.stop());
      window.__msInstalled = true;
    } catch {}
  }
}

//=================================================
// FILE: /src/PlayerCore.ts
// src/PlayerCore.ts
// Ядро Howler.js для vi3na1bita-music: плейлист, play/pause/stop/prev/next,
// repeat/shuffle/favoritesOnly, громкость/позиция, автопереход, MediaSession, тикер времени.

export type PlayerTrack = {
  src: string;
  title: string;
  artist?: string;
  album?: string;
  cover?: string;
  lyrics?: string;
  fulltext?: string;
};

type PlayerCoreEvents = {
  onPlay?: (track: PlayerTrack | null, index: number) => void;
  onPause?: (track: PlayerTrack | null, index: number) => void;
  onStop?: (track: PlayerTrack | null, index: number) => void;
  onTrackChange?: (track: PlayerTrack | null, index: number) => void;
  onEnd?: (track: PlayerTrack | null, index: number) => void;
  onTick?: (positionSec: number, durationSec: number) => void;
  onSleepTriggered?: (track: PlayerTrack | null, index: number) => void;
};

type PlayerCoreOptions = {
  tickIntervalMs?: number;
  events?: PlayerCoreEvents;
};

declare const Howler: any; // глобальный из CDN
declare class Howl {
  constructor(opts: any);
  play(): void;
  pause(): void;
  stop(): void;
  unload(): void;
  seek(sec?: number): number;
  duration(): number;
  volume(v?: number): number;
}

export class PlayerCore {
  private playlist: PlayerTrack[] = [];
  private index = 0;
  private howl: Howl | null = null;
  private events: PlayerCoreEvents = {};
  private repeat = false;
  private shuffle = false;
  private favoritesOnly = false;
  private favorites: number[] = [];
  private shuffled: number[] = [];
  private _ticker: ReturnType<typeof setInterval> | null = null;
  private _tickIntervalMs: number;
  private _isPaused = true;
  private _albumArtist = '';
  private _albumTitle = '';
  private _albumCover = '';

  private _sleepTimerId: ReturnType<typeof setTimeout> | null = null;
  private _sleepTargetTs = 0;

  constructor(opts: PlayerCoreOptions = {}) {
    this._tickIntervalMs = Math.max(100, opts.tickIntervalMs || 250);
    if (opts.events) this.events = { ...opts.events };
    this._installMediaSessionHandlersOnce();
  }

  setPlaylist(tracks: PlayerTrack[], startIndex = 0, albumMeta?: { artist?: string; album?: string; cover?: string }) {
    this.stop();
    this.playlist = Array.isArray(tracks) ? tracks.slice() : [];
    this.index = Math.max(0, Math.min(this.playlist.length - 1, startIndex || 0));
    this._albumArtist = (albumMeta?.artist) || (tracks?.[0]?.artist) || '';
    this._albumTitle  = (albumMeta?.album)  || (tracks?.[0]?.album)  || '';
    this._albumCover  = (albumMeta?.cover)  || (tracks?.[0]?.cover)  || '';
    this._syncShuffle(true);
    this._fire('onTrackChange', this.getCurrentTrack(), this.index);
  }

  on(events: PlayerCoreEvents) { this.events = { ...this.events, ...events }; }
  setEvents(events: PlayerCoreEvents) { this.events = { ...events }; }

  setRepeat(v: boolean) { this.repeat = !!v; }
  setShuffle(v: boolean) { this.shuffle = !!v; this._syncShuffle(true); }
  setFavoritesOnly(v: boolean, favorites: number[] = []) {
    this.favoritesOnly = !!v;
    this.favorites = Array.isArray(favorites) ? favorites.slice() : [];
    this._syncShuffle(true);
  }

  play(index?: number) {
    if (typeof index === 'number') this.index = this._clampIndex(index);
    if (!this.playlist.length) return;

    this._stopHowl();
    const tr = this.getCurrentTrack();
    if (!tr) return;

    this.howl = new Howl({
      src: [tr.src],
      html5: true,
      onend: () => {
        if (this.repeat) { this.play(); return; }
        this.next();
        this._fire('onEnd', tr, this.index);
      },
      onplay: () => {
        this._isPaused = false;
        this._fire('onPlay', tr, this.index);
        this._fire('onTrackChange', tr, this.index);
        this._updateMediaSessionMeta();
        this._startTicker();
      },
      onpause: () => { this._isPaused = true; this._fire('onPause', tr, this.index); this._stopTicker(); },
      onstop:  () => { this._isPaused = true; this._fire('onStop',  tr, this.index); this._stopTicker(); }
    });

    try {
      const saved = parseFloat(localStorage.getItem('playerVolume') || '');
      if (Number.isFinite(saved)) this.setVolume(saved);
    } catch {}
    this.howl.play();
  }

  pause() { if (this.howl && !this._isPaused) this.howl.pause(); }
  stop()  { this._stopHowl(); this._isPaused = true; this._fire('onStop', this.getCurrentTrack(), this.index); }

  next() { const n = this._nextIndex(); if (n < 0) return; this.index = n; this.play(); }
  prev() { const p = this._prevIndex(); if (p < 0) return; this.index = p; this.play(); }

  setVolume(v: number) {
    const vol = Math.max(0, Math.min(1, Number(v)));
    if (this.howl) this.howl.volume(vol);
    else if (typeof Howler !== 'undefined') Howler.volume(vol);
  }
  getVolume(): number {
    if (this.howl) return this.howl.volume();
    if (typeof Howler !== 'undefined') return Howler.volume();
    return 1;
  }

  seek(sec?: number): number | void {
    if (!this.howl) return;
    if (typeof sec === 'number') this.howl.seek(Math.max(0, sec));
    else return Number(this.howl.seek()) || 0;
  }
  getSeek(): number { return (this.seek() as number) || 0; }
  getDuration(): number { return this.howl ? (this.howl.duration() || 0) : 0; }

  // Публичный «следующий» индекс по текущей логике shuffle/favoritesOnly
  getNextIndex(): number {
    return this._nextIndex();
  }

  // Снимок плейлиста для UI (заголовки и пр.)
  getPlaylistSnapshot(): Array<{ title: string; artist: string; album: string; cover: string; lyrics: string; src: string; fulltext: string; }> {
    return (this.playlist || []).map(t => ({
      title: t?.title || '',
      artist: t?.artist || this._albumArtist || '',
      album: t?.album || this._albumTitle || '',
      cover: t?.cover || this._albumCover || '',
      lyrics: t?.lyrics || '',
      src: t?.src || '',
      fulltext: (t as any)?.fulltext || ''
    }));
  }

  isPlaying() { return !!this.howl && !this._isPaused; }
  getIndex() { return this.index; }
  getCurrentTrack(): PlayerTrack | null {
    if (!this.playlist.length) return null;
    return this.playlist[this.index] || null;
  }

  destroy() {
    this.stop(); this._stopTicker(); this.playlist = []; this.events = {};
  }

  // ===== INTERNAL =====
  private _clampIndex(i: number) { return Math.max(0, Math.min(this.playlist.length - 1, i)); }
  private _fire<K extends keyof PlayerCoreEvents>(name: K, ...args: any[]) { try { const fn = this.events && this.events[name]; if (typeof fn === 'function') (fn as any)(...args); } catch {} }
  private _stopHowl() { if (this.howl) { try { this.howl.stop(); this.howl.unload(); } catch {} this.howl = null; } }

  private _filteredIndices(): number[] {
    if (!this.playlist.length) return [];
    if (this.favoritesOnly && this.favorites.length) {
      return this.favorites.filter(i => Number.isInteger(i) && i >= 0 && i < this.playlist.length);
    }
    return this.playlist.map((_, i) => i);
  }
  private _syncShuffle(force: boolean = false) {
    if (!this.shuffle) { this.shuffled = []; return; }
    const base = this._filteredIndices();

    if (!force &&
        Array.isArray(this.shuffled) &&
        this.shuffled.length === base.length &&
        this.shuffled.includes(this.index)) {
      return;
    }

    const arr = base.slice();
    for (let j = arr.length - 1; j > 0; j--) {
      const k = Math.floor(Math.random() * (j + 1));
      [arr[j], arr[k]] = [arr[k], arr[j]];
    }
    const i = arr.indexOf(this.index);
    if (i > 0) { arr.splice(i, 1); arr.unshift(this.index); }
    this.shuffled = arr;
  }

  private _displayList(): number[] {
    const base = this._filteredIndices();
    if (this.shuffle && this.shuffled.length) return this.shuffled.slice();
    return base;
  }
  private _nextIndex(): number {
    const arr = this._displayList(); if (!arr.length) return -1;
    const pos = arr.indexOf(this.index);
    const nextIdx = (pos + 1) % arr.length;
    return arr[nextIdx];
  }
  private _prevIndex(): number {
    const arr = this._displayList(); if (!arr.length) return -1;
    const pos = arr.indexOf(this.index);
    const prevIdx = (pos - 1 + arr.length) % arr.length;
    return arr[prevIdx];
  }

  private _startTicker() {
    if (this._ticker) return;
    this._ticker = setInterval(() => {
      try {
        if (!this.isPlaying()) return;
        const pos = this.getSeek() || 0;
        const dur = this.getDuration() || 0;
        const fn = this.events && this.events.onTick;
        if (typeof fn === 'function') fn(pos, dur);
      } catch {}
    }, this._tickIntervalMs);
  }
  private _stopTicker() { if (this._ticker) { clearInterval(this._ticker); this._ticker = null; } }

  // ===== Sleep timer API =====
  setSleepTimer(ms: number) {
    try { this.clearSleepTimer(); } catch {}
    const n = Number(ms);
    if (!Number.isFinite(n) || n <= 0) return;
    this._sleepTargetTs = Date.now() + n;
    this._sleepTimerId = setTimeout(() => {
      this._sleepTimerId = null;
      this._sleepTargetTs = 0;
      try {
        if (this.howl && !this._isPaused) this.howl.pause();
      } catch {}
      this._fire('onSleepTriggered', this.getCurrentTrack(), this.index);
    }, n);
  }
  clearSleepTimer() {
    if (this._sleepTimerId) {
      try { clearTimeout(this._sleepTimerId); } catch {}
      this._sleepTimerId = null;
    }
    this._sleepTargetTs = 0;
  }
  getSleepTimerTarget(): number {
    return this._sleepTargetTs || 0;
  }

  private _updateMediaSessionMeta() {
    if (!('mediaSession' in navigator)) return;
    const t = this.getCurrentTrack();
    try {
      (navigator as any).mediaSession.metadata = new (window as any).MediaMetadata({
        title: t?.title || '',
        artist: t?.artist || this._albumArtist || '',
        album: t?.album || this._albumTitle || '',
        artwork: (t?.cover || this._albumCover) ? [
          { src: t?.cover || this._albumCover, sizes: '512x512', type: 'image/png' }
        ] : []
      });
      (navigator as any).mediaSession.playbackState = this.isPlaying() ? 'playing' : 'paused';
      const self = this;
      (navigator as any).mediaSession.setActionHandler('play',         () => self.play());
      (navigator as any).mediaSession.setActionHandler('pause',        () => self.pause());
      (navigator as any).mediaSession.setActionHandler('previoustrack',() => self.prev());
      (navigator as any).mediaSession.setActionHandler('nexttrack',    () => self.next());
      (navigator as any).mediaSession.setActionHandler('seekbackward', (d: any) => self.seek((self.getSeek() || 0) - (d.seekOffset || 10)));
      (navigator as any).mediaSession.setActionHandler('seekforward',  (d: any) => self.seek((self.getSeek() || 0) + (d.seekOffset || 10)));
      (navigator as any).mediaSession.setActionHandler('seekto',       (d: any) => { if (typeof d.seekTime === 'number') self.seek(d.seekTime); });
      (navigator as any).mediaSession.setActionHandler('stop',         () => self.stop());
    } catch {}
  }

  private _installMediaSessionHandlersOnce() {
    // Хэндлеры действий задаются вместе с метаданными при onplay/track-change.
  }
}

//=================================================
// FILE: /styles/main.css
:root {
  --primary-bg: #181818;
  --primary-color: #E80100;
  --secondary-color: #4daaff;
  --text-color: #f2f2f2;
  --modal-bg: #252d39;
  --border-color: #394866;
}

* { box-sizing: border-box; }
html, body { height: 100%; }

body {
  min-height: 100vh;
  background: var(--primary-bg);
  color: var(--text-color);
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  min-width: 100vw;
  padding-top: env(safe-area-inset-top);
}

.hidden { display: none !important; }

/* Promocode */
#promocode-block {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--primary-bg);
  z-index: 100;
}

.promo-inner {
  display: flex;
  flex-direction: column;
  align-items: center;
  background: rgba(15,18,24,0.98);
  border-radius: 16px;
  box-shadow: 0 6px 24px #0008;
  padding: 36px 26px 32px 26px;
  min-width: 260px;
}

.promo-cover {
  width: 256px;
  height: 256px;
  object-fit: cover;
  border-radius: 12px;
  box-shadow: 0 4px 24px #000c;
  margin-bottom: 19px;
  display: block;
  background: var(--primary-bg);
}

#promo-inp {
  padding: 10px;
  border-radius: 8px;
  border: 1px solid var(--border-color);
  background: rgba(255,255,255,0.1);
  color: var(--text-color);
  margin: 10px 0;
  width: 100%;
  font-size: 16px;
}

#promo-btn {
  padding: 10px 20px;
  background: var(--primary-color);
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-weight: bold;
  transition: opacity 0.2s;
}

#promo-btn:hover:not(:disabled) { opacity: .8; }
#promo-btn:disabled { opacity: .5; cursor: not-allowed; }
#promo-error { color: #ff6b6b; margin-top: 10px; font-size: 14px; }

/* Main block */
#main-block {
  max-width: 420px;
  margin: 0 auto;
  flex: 1 0 auto;
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
  padding: 0 10px;
}

header {
  width: 100%;
  text-align: center;
  margin: 0 auto;
}

.active-album-title {
  width: 100%;
  max-width: 400px;
  margin: 18px auto 6px auto;
  text-align: center;
  color: #eaf2ff;
  font-weight: 900;
  letter-spacing: .01em;
  line-height: 1.15;
  text-shadow: 0 1px 0 rgba(0,0,0,.35);
  font-size: clamp(18px, 4.6vw, 24px);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.active-album-title.fav { color: #ffd166; letter-spacing: .06em; }
.active-album-title.news { color: #8ab8fd; letter-spacing: .02em; }

/* Cover/Gallery */
#cover-wrap {
  width: 100%;
  max-width: 400px;
  margin: 14px auto 0 auto;
  aspect-ratio: 1/1;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
}

.cover-gallery-arrow {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  z-index: 2;
  border: none;
  cursor: pointer;
  background: none;
  padding: 0;
  width: 44px;
  height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: opacity 0.2s;
  visibility: hidden;
  pointer-events: none;
}

.cover-gallery-arrow:hover { opacity: 0.8; }
#cover-gallery-arrow-left { left: 7px; }
#cover-gallery-arrow-right { right: 7px; }
#cover-wrap.gallery-nav-ready .cover-gallery-arrow {
  visibility: visible;
  pointer-events: auto;
}

#cover-slot {
  width: 100%;
  height: 100%;
  border-radius: 12px;
  overflow: hidden;
  background: var(--primary-bg);
  box-shadow: 0 4px 24px rgba(0,0,0,0.3);
  position: relative;
}

#cover-slot img,
#cover-slot iframe {
  width: 100%;
  height: 100%;
  display: block;
  border: 0;
  background: transparent;
}

#cover-slot img { object-fit: contain; }

/* Logo */
.logo-bottom {
  max-width: 112px;
  width: 23vw;
  min-width: 66px;
  height: auto;
  display: block;
  margin: 0 auto 15px auto !important;
  cursor: pointer;
  transition: transform 0.1s ease-out;
  will-change: transform;
  transform: translateZ(0);
  transform-origin: center center;
}

/* Socials */
.socials-under-cover {
  margin: 14px auto 0 auto;
  width: 100%;
  max-width: 398px;
  text-align: center;
  font-size: 1.03em;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 12px;
}

.socials-under-cover a {
  color: var(--secondary-color);
  text-decoration: none;
  transition: color 0.2s;
}

.socials-under-cover a:hover { color: var(--text-color); }

/* Track list */
.track-list {
  margin: 0 auto;
  max-width: 370px;
  width: 100%;
  font-size: 1.05em;
  color: #eee;
  background: none;
  padding: 0;
}

.track-list.filtered .track:not(.is-favorite) {
  display: none !important;
}

.track {
  display: flex;
  align-items: center;
  padding: 7px 8px;
  border-bottom: 1px solid var(--border-color);
  cursor: pointer;
  transition: background 0.13s, transform 0.1s;
  background: none;
}

.track:hover { background: rgba(255,255,255,0.05); }
.track.current { background: #232b38; }
.track:active {
  transform: scale(0.98);
  background: rgba(255,255,255,0.08) !important;
}

.track.inactive {
  opacity: 0.45;
  filter: grayscale(0.6);
}

.tnum {
  min-width: 27px;
  color: #8ab8fd;
}

.track-title {
  margin-left: 7px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex: 1;
}

.like-star {
  margin-left: auto;
  width: 19px;
  height: 19px;
  cursor: pointer;
  opacity: 0.97;
  border: none;
  background: none;
  padding: 0;
  transition: transform 0.2s, filter 0.13s, opacity 0.13s;
}

.like-star:hover {
  filter: brightness(1.13);
  opacity: 1;
  transform: scale(1.1);
}

.like-star.animating {
  animation: starPulse 0.3s;
}

@keyframes starPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.3); }
}

/* Album icons */
.album-icons {
  display: flex;
  gap: 10px;
  align-items: center;
  justify-content: center;
  margin: 12px auto 0 auto;
  max-width: 400px;
  overflow-x: auto;
  padding: 4px 0;
}

.album-icon {
  width: 60px;
  height: 60px;
  border-radius: 10px;
  overflow: hidden;
  border: 1px solid var(--border-color);
  cursor: pointer;
  filter: grayscale(70%) brightness(.88);
  opacity: .72;
  transition: transform .15s, filter .15s, opacity .15s, box-shadow .15s, width .15s ease, height .15s ease;
  flex: 0 0 auto;
}

.album-icon.active {
  filter: none;
  opacity: 1;
  box-shadow: 0 2px 10px rgba(0,0,0,.35);
  width: 66px;
  height: 66px;
}

.album-icon:hover { transform: translateY(-2px); }

/* Bottom controls */
.bottom-controls-center {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  margin: 32px auto 0 auto;
  gap: 8px;
  width: 100%;
  max-width: 280px;
  padding-bottom: env(safe-area-inset-bottom);
}

.filter-favorites-btn {
  display: block;
  margin: 0 auto 15px auto;
  padding: 10px 20px;
  background: linear-gradient(135deg,#2a2a2a,#1a1a1a);
  color: var(--secondary-color);
  border: 2px solid var(--border-color);
  border-radius: 12px;
  font-size: .95em;
  font-weight: bold;
  cursor: pointer;
  transition: .3s;
  text-align: center;
  min-width: 100%;
  white-space: nowrap;
  box-shadow: 0 2px 8px rgba(0,0,0,.3);
}

.filter-favorites-btn:hover {
  background: linear-gradient(135deg,#3a3a3a,#2a2a2a);
  border-color: var(--secondary-color);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,.5);
}

.filter-favorites-btn.filtered {
  background: linear-gradient(135deg,#4a1a1a,#2a0a0a);
  border-color: var(--primary-color);
  color: #fff;
}

#install-pwa-btn,
#download-album-main {
  color: #fff;
  background: var(--secondary-color);
  border: none;
  border-radius: 7px;
  font-size: 1.07em;
  font-weight: bold;
  letter-spacing: .02em;
  margin: 15px 0 5px 0;
  padding: 8px 13px;
  cursor: pointer;
  width: 98%;
  box-shadow: 0 4px 14px #0005;
  transition: background .2s;
}

#download-album-main {
  background: var(--primary-color);
  font-size: 1.09em;
  margin-bottom: 8px;
}

#install-pwa-btn:hover { background: #3275c2; }
#download-album-main:hover { background: #c60000; }

.feedback-link,
.support-link {
  color: var(--secondary-color) !important;
  text-decoration: underline !important;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: .03em;
  cursor: pointer;
  transition: color .18s;
  font-size: 1em;
  display: block;
  text-align: center;
  width: 100%;
  margin: 0;
}

.feedback-link:hover,
.support-link:hover {
  color: #fff !important;
}

.offline-btn {
  min-width: 102px;
  height: 38px;
  font-size: 1.05em;
  font-weight: bold;
  border: none;
  border-radius: 9px;
  cursor: pointer;
  letter-spacing: .07em;
  box-shadow: 0 2px 8px #06000032;
  transition: background .2s, color .14s;
  display: block;
  margin: 0 auto;
}

.offline-btn.online {
  background: var(--primary-color);
  color: #fff;
}

.offline-btn.offline {
  background: #27b34c;
  color: #fff;
}

.hotkeys-btn {
  color: var(--secondary-color) !important;
  text-decoration: underline !important;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: .03em;
  cursor: pointer;
  transition: color .18s;
  font-size: 1em;
  display: block;
  text-align: center;
  width: 100%;
  margin: 0;
  background: none;
  border: none;
  padding: 8px;
}

.hotkeys-btn:hover { color: #fff !important; }

@media (max-width: 600px) {
  .hotkeys-btn { display: none !important; }
}

/* Toasts */
.toast {
  position: fixed;
  bottom: 80px;
  left: 50%;
  transform: translateX(-50%) translateY(100px);
  background: #2a2a2a;
  border-radius: 12px;
  padding: 15px 20px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.3);
  z-index: 9999;
  opacity: 0;
  transition: all 0.3s ease;
  max-width: 90%;
  word-wrap: break-word;
  pointer-events: none;
}

.toast.show {
  transform: translateX(-50%) translateY(0);
  opacity: 1;
}

.toast-content {
  display: flex;
  align-items: center;
  gap: 10px;
}

.toast-emoji {
  width: 24px;
  height: 24px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.toast-info { border-left: 4px solid var(--secondary-color); }
.toast-success { border-left: 4px solid #27b34c; }
.toast-error { border-left: 4px solid var(--primary-color); }
.toast-warning { border-left: 4px solid #ff9800; }
.toast-offline { border-left: 4px solid #666; }

/* Modals */
.modal-bg {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.62);
  display: none;
  align-items: center;
  justify-content: center;
  backdrop-filter: blur(4px);
  z-index: 99;
}

.modal-bg.active {
  display: flex;
  animation: fadeIn .3s;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.modal-feedback {
  background: var(--modal-bg);
  border-radius: 14px;
  padding: 24px 20px;
  min-width: 215px;
  max-width: 96vw;
  box-shadow: 0 4px 32px #0009;
  position: relative;
  animation: slideUp .3s;
}

@keyframes slideUp {
  from {
    transform: translateY(20px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

.modal-feedback .bigclose {
  background: none;
  border: none;
  position: absolute;
  top: 13px;
  right: 13px;
  cursor: pointer;
  color: #eee;
  border-radius: 50%;
  width: 32px;
  height: 32px;
  transition: transform .2s;
}

.modal-feedback .bigclose:hover {
  transform: scale(1.1);
}

.modal-feedback .bigclose svg {
  width: 31px;
  height: 31px;
}

/* Mini mode */
.mini-now {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 8px;
  border-radius: 8px;
  background: #232b38;
  margin-bottom: 6px;
}

.mini-now .tnum {
  color: #8ab8fd;
  min-width: 27px;
}

.mini-now .track-title {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.next-up {
  display: none;
  margin: 8px 4px 0 4px;
  font-size: .98em;
  align-items: center;
  gap: 6px;
}

.mini-mode .next-up {
  display: flex;
}

.next-up .label {
  color: #8ab8fd;
  opacity: .9;
}

.next-up .title {
  color: var(--primary-color);
  font-weight: 700;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  min-width: 0;
  flex: 1;
}

/* iOS specific */
body.ios .volume-control-wrapper {
  display: none !important;
}

@media (display-mode: standalone) {
  .bottom-controls-center {
    padding-bottom: calc(env(safe-area-inset-bottom) + 10px);
  }
}

