/* eslint-disable no-console */
"use strict";

/**
 * generate-context.js
 *
 * Генератор .meta/project-full.txt и .meta/project-adaptive.txt
 * Требования (выполнены):
 * 1) В начале — блок «ПРАВИЛА ДЛЯ НЕЙРОСЕТЕЙ», затем мета‑блок с названием/URL репозитория и пометкой про GitHub.
 * 2) СТРУКТУРА ПРОЕКТА — ПОЛНОЕ дерево ВСЕХ файлов (включая assets/), но без .git/** и .meta/**.
 *    Дополнительно защищаемся от самовключения результирующих файлов.
 * 3) После дерева — секция «ФАЙЛЫ»: только текстовые файлы, по приоритетам (critical → high → medium → low),
 *    каждый файл выводится целиком. Здесь assets/** исключаем (по вашему требованию), .meta/** тоже исключаем.
 * 4) НЕТ блока «Критичные логи».
 * 5) Adaptive-режим ограничивает общий объём строк параметром --max-lines (по умолчанию 20000).
 *
 * Запуск:
 *   node generate-context.js --mode=both --max-lines=20000
 *   node generate-context.js --mode=full
 *   node generate-context.js --mode=adaptive --out-dir=.meta
 *
 * Аргументы:
 *   --mode=both|full|adaptive
 *   --max-lines=ЧИСЛО           // только для adaptive
 *   --out-dir=ПУТЬ              // по умолчанию .meta
 *   --root=ПУТЬ                 // корень проекта (по умолчанию текущая папка)
 */

const fs = require("fs");
const path = require("path");

// -------------------- CLI --------------------
const argv = Object.fromEntries(
  process.argv.slice(2).map(a => {
    const [k, ...r] = a.replace(/^--/, "").split("=");
    return [k, r.join("=") === "" ? true : r.join("=")];
  })
);

const ROOT     = path.resolve(argv.root || __dirname);
const META_DIR = path.resolve(argv["out-dir"] || path.join(ROOT, ".meta"));
const MODE     = (argv.mode || "both").toLowerCase(); // full | adaptive | both
const MAX_LINES = Number(argv["max-lines"] || 20000);

// Гарантируем наличие .meta
if (!fs.existsSync(META_DIR)) fs.mkdirSync(META_DIR, { recursive: true });

const FULL_FILE    = path.join(META_DIR, "project-full.txt");
const ADAPTIVE_FILE= path.join(META_DIR, "project-adaptive.txt");

// Относительные пути к self-файлам (для защиты от самовключения)
const SELF_FULL_REL  = toUnix(path.relative(ROOT, FULL_FILE));
const SELF_ADAPT_REL = toUnix(path.relative(ROOT, ADAPTIVE_FILE));

// -------------------- Настройки --------------------

// Текстовые расширения, содержимое которых включаем в секцию «ФАЙЛЫ»
const TEXT_EXTS = new Set([
  ".html",".htm",".css",".js",".mjs",".cjs",".ts",".tsx",
  ".json",".webmanifest",".md",".txt",".yml",".yaml"
]);

/**
 * Исключения для СЕКЦИИ «ФАЙЛЫ» (только к листингу контента, НЕ к дереву):
 * - По требованию исключаем .meta/** и assets/** (не попадут в контент),
 * - Исключаем служебные каталоги.
 */
const EXCLUDE_FILES_PATTERNS = [
  "node_modules/**",
  ".git/**",
  ".meta/**",
  "assets/**",
  ".next/**","dist/**","build/**","out/**","coverage/**",
  ".cache/**",".vscode/**",".idea/**",".husky/**",
  "**/*.log",".DS_Store"
].map(globToRegExp);

/**
 * Исключения ТОЛЬКО для СТРУКТУРЫ ДЕРЕВА:
 * - По требованию показываем ВСЕ файлы, включая assets/**.
 * - Исключаем только .git/**, .meta/** и служебные каталоги (node_modules и т.п.),
 *   плюс защищаемся от самовключения итоговых файлов.
 */
const EXCLUDE_TREE_PATTERNS = [
  "node_modules/**",
  ".git/**",
  ".meta/**",
  ".next/**","dist/**","build/**","out/**","coverage/**",
  ".cache/**",".vscode/**",".idea/**",".husky/**",
  "**/*.log",".DS_Store"
].map(globToRegExp);

// Приоритеты для секции «ФАЙЛЫ»
const PRIORITY = {
  critical: [
    /^index\.html?$/i,
    /^service-worker\.js$/i,
    /^manifest\.json$/i,
    /^albums\.json$/i,
    /^custom\.json$/i,
    /^news\.html?$/i,
    /^generate-index\.(js|mjs|cjs)$/i,
    /^albums\/gallery\/[^/]+\/index\.json$/i,
    /^\.github\/workflows\/.*\.ya?ml$/i
  ],
  high: [
    /^AudioController\.(js|mjs|cjs|ts)$/i,
    /^GlobalState\.(js|mjs|cjs|ts)$/i,
    /^scripts\/.*\.(mjs|js|ts)$/i,
    /^performance\/.*\.(js|ts)$/i,
    /^.*\.(ya?ml)$/i
  ],
  medium: [
    /^.*\.(js|mjs|cjs|ts|tsx|json|html?|css)$/i
  ],
};

// -------------------- Утилиты --------------------
function toUnix(p) {
  return String(p).replace(/\\/g, "/");
}
function globToRegExp(pat) {
  const esc = pat
    .replace(/[.+^${}()|[\]\\]/g, "\\$")
    .replace(/\*\*/g, "___GLOBSTAR___")
    .replace(/\*/g, "[^/]*")
    .replace(/___GLOBSTAR___/g, ".*");
  return new RegExp("^" + esc + "$");
}
function isTextFile(rel) {
  return TEXT_EXTS.has(path.extname(rel).toLowerCase());
}
function readText(rel) {
  try { return fs.readFileSync(path.join(ROOT, rel), "utf8"); }
  catch (e) { return `// read error: ${e.message}`; }
}
function countLines(s) {
  return (s.match(/\n/g) || []).length + (s.length ? 1 : 0);
}

// Исключения для секции «ФАЙЛЫ»
function isExcludedForFiles(rel) {
  const u = toUnix(rel);
  if (!u) return true;
  if (u === SELF_FULL_REL || u === SELF_ADAPT_REL) return true; // защита от самовключения
  return EXCLUDE_FILES_PATTERNS.some(re => re.test(u));
}
// Исключения для дерева
function isExcludedForTree(rel) {
  const u = toUnix(rel);
  if (!u) return true;
  if (u === SELF_FULL_REL || u === SELF_ADAPT_REL) return true; // защита от самовключения
  return EXCLUDE_TREE_PATTERNS.some(re => re.test(u));
}

// -------------------- Сканирование --------------------
function listAllEntries(includeFiles = true, forTree = false) {
  const res = [];
  const stack = [ROOT];

  while (stack.length) {
    const dir = stack.pop();
    let entries = [];
    try { entries = fs.readdirSync(dir, { withFileTypes: true }); } catch { continue; }

    for (const e of entries) {
      const full = path.join(dir, e.name);
      const rel = toUnix(path.relative(ROOT, full)) || ".";

      // Выбор правил исключения: для дерева — свои, для контента — свои
      const excluded = forTree ? isExcludedForTree(rel) : isExcludedForFiles(rel);
      if (excluded) continue;

      if (e.isDirectory()) {
        res.push({ rel, full, dir: true });
        stack.push(full);
      } else if (e.isFile() && includeFiles) {
        res.push({ rel, full, dir: false });
      }
    }
  }

  // Папки сверху, затем файлы; внутри — по алфавиту
  res.sort((a, b) => (a.dir !== b.dir ? (a.dir ? -1 : 1) : a.rel.localeCompare(b.rel)));
  return res;
}

function listTextFilesForContent() {
  return listAllEntries(true, /*forTree*/ false)
    .filter(e => !e.dir && isTextFile(e.rel))
    .map(e => e.rel);
}

// -------------------- Репозиторий --------------------
function readRepoMeta() {
  let url = "";
  try {
    const cfg = path.join(ROOT, ".git", "config");
    if (fs.existsSync(cfg)) {
      const raw = fs.readFileSync(cfg, "utf8");
      const m = raw.match(/url\s*=\s*(.+)\n/);
      if (m) url = m[1].trim();
    }
  } catch {}
  return {
    name: path.basename(ROOT),
    url: url || "(URL репозитория не обнаружен; укажите в .git/config)",
    madeWith: "Проект делается и обслуживается средствами https://github.com/ (GitHub Pages + GitHub Actions).",
  };
}

// -------------------- Блоки заголовка --------------------
function rulesBlock() {
  return [
    "ПРАВИЛА ДЛЯ НЕЙРОСЕТЕЙ (важно для качества ответов):",
    "- Язык ответов: по умолчанию RU. Английский — если явно попросят или в именах/терминах.",
    "- Всегда начинай с полного и детального анализа всего приложения.",
    "- Всегда указывай точные пути файлов при ссылках (например, src/app/(main)/timeline/page.tsx).",
    "- Любой код выводи ТОЛЬКО в тройных бэктиках с указанием языка, например:",
    "  ```ts",
    "  export function x() {}",
    "  ```",
    "- Не используй тяжелое форматирование. Разрешены: списки, короткие таблицы.",
    "- Если требуются изменения в файле — показывай минимальный патч (unified diff) или целиком обновлённый файл (не смешивать).",
    "- Не выдумывай зависимости и API. Если данных нет — явно скажи «нужно уточнение».",
    "- Учитывай что я работаю через web интерфейс github.com и не возможности локально делать проект.",
    "- Стиль кода: TypeScript strict, ESM-импорты, 2 пробела.",
    "- НИКОГДА не генерируй весь файл project-full целиком; только блоки для замены со строгим указанием места.",
    "- Формат изменений: -> ФАЙЛ: путь -> НАЙТИ: [фрагмент дословно] -> ЗАМЕНИТЬ НА: [полный новый блок].",
    "- Если какой то файл приложения требует полной замены, то присылай именно этого файла полный и правильный (соответствующий моему проекту) файл который этого требует. ",
    "- Сохраняй комментарии, форматирование и импорт-структуру.",
    "- Если удаляем блок — укажи строку перед и строку после (из реального кода).",
    "- Всегда пиши краткое обоснование, что и почему делаем.",
    "- Очень важно! Прервать воспроизведение могут только кнопки Пауза, стоп и срабатывание таймера, при всех остальных сценариях какие бы не были плеер всегда играет и на всех устройствах, ничего другого его не может остановить или сбросить или отключить звук, вообще никакая другая функция - это базовое правило этого проигрывателя.",
    "- Всегда предлагай список дальнейших улучшений и критических ошибок если они встречаются во всей программе при анализе.",
    ""
  ].join("\n");
}

function metaBlock() {
  const m = readRepoMeta();
  return [
    `Название репозитория: ${m.name}`,
    `Адрес репозитория: ${m.url}`,
    "# ПОЛНЫЙ И ДЕТАЛЬНЫЙ АНАЛИЗ ПРИЛОЖЕНИЯ "ВИТРИНА РАЗБИТА"

## 1. ОБЩАЯ АРХИТЕКТУРА ПРИЛОЖЕНИЯ

### 1.1. Тип приложения
Статическое Progressive Web Application (PWA), развернутое на GitHub Pages. Приложение полностью клиентское, не требует серверной части для основной функциональности. Все данные хранятся в репозитории GitHub и доступны через Service Worker для офлайн-режима.

### 1.2. Архитектурные принципы
- **JAMstack подход**: JavaScript, APIs, Markup
- **SPA-архитектура**: Единственная точка входа (index.html) с динамической загрузкой контента
- **Service Worker First**: Все сетевые запросы обрабатываются Service Worker для кэширования и офлайн-доступа
- **Модульная структура**: Разделение на функциональные компоненты (AudioController, GlobalState)
- **Адаптивный дизайн**: Поддержка всех устройств от мобильных до десктопов

### 1.3. Технологический стек
- **Язык**: JavaScript (ES6+)
- **Инструменты**: GitHub Actions для CI/CD
- **PWA**: Web App Manifest, Service Worker, Notification API
- **API**: Media Session API, Web Locks API, Wake Lock API, Background Sync
- **Хранилище**: localStorage, IndexedDB (через кэш Service Worker)
- **Мониторинг**: RUM (Real User Monitoring)

## 2. СТРУКТУРА ФАЙЛОВ И ДИРЕКТОРИЙ

```
vi3na1bita/
├── .github/
│   └── workflows/
│       ├── collect-critical-logs.yml    # Сбор логов CI
│       ├── generate-context.yml         # Генерация контекста для разработки
│       └── pages.yml                     # Деплой на GitHub Pages
├── .meta/                                # Мета-данные для разработки
│   └── ci-last.txt
├── albums/
│   ├── gallery/                          # Центральные галереи альбомов
│   │   ├── 00/                           # Галерея альбома 'krevetochka'
│   │   ├── 01/                           # Галерея альбома 'mezhdu-zlom-i-dobrom'
│   │   ├── 02/                           # Галерея альбома 'golos-dushi'
│   │   └── news/                         # Галерея новостей
│   └── index.json                        # Индекс галерей
├── assets/
│   └── emoji/                            # Эмодзи для интерфейса
│       └── noto/                         # Набор Noto Emoji
├── icons/                                # Иконки для PWA
├── img/                                  # Изображения приложения
│   ├── desktop/                          # Изображения для десктопа
│   ├── icon_album/                       # Иконки альбомов
│   ├── mobile/                           # Изображения для мобильных
│   └── ...                               # Прочие изображения
├── news/                                 # Новости приложения
│   └── news.json
├── performance/                          # Мониторинг производительности
│   └── rum.js
├── scripts/                              # Вспомогательные скрипты
│   └── validate-config.mjs               # Валидация конфигурации
├── .nojekyll                             # Отключение Jekyll на GitHub Pages
├── .gitignore
├── albums.json                           # Конфигурация альбомов
├── AudioController.js                    # Контроллер аудио
├── custom.json                           # Кастомные настройки
├── generate-context.js                   # Скрипт генерации контекста
├── generate-index.js                     # Скрипт генерации индексов
├── GlobalState.js                        # Глобальное состояние
├── index.html                            # Основной файл приложения
├── manifest.json                         # Web App Manifest
├── news.html                             # Страница новостей
└── service-worker.js                     # Service Worker
```

## 3. ФУНКЦИОНАЛЬНЫЕ МОДУЛИ

### 3.1. Модуль управления воспроизведением (AudioController)

**Назначение**: Централизованное управление аудио-воспроизведением.

**Основные функции**:
- Инициализация аудио-элемента
- Воспроизведение треков
- Пауза/остановка воспроизведения
- Управление громкостью
- Отслеживание времени воспроизведения
- Работа с событиями аудио (ended, timeupdate, error)

**Особенности реализации**:
- Поддержка воспроизведения в фоновом режиме
- Интеграция с Media Session API
- Обработка ошибок и недоступных ресурсов
- Поддержка Range-запросов для потокового воспроизведения

### 3.2. Модуль глобального состояния (GlobalState)

**Назначение**: Хранение и управление состоянием приложения между перезагрузками.

**Хранимые данные**:
- Текущий альбом и трек
- Состояние воспроизведения
- Настройки плеера (shuffle, repeat, favoritesOnly)
- Визуальные настройки (анимации, пульсация)
- Офлайн-статус

**Механизмы сохранения**:
- localStorage для базовых настроек
- SessionStorage для временного состояния
- Синхронизация со Service Worker для офлайн-данных

### 3.3. Модуль Service Worker

**Назначение**: Обеспечение офлайн-доступа и оптимизация загрузки ресурсов.

**Стратегии кэширования**:
- Навигация (HTML): Network-first с таймаутом и fallback
- JSON-данные: Network-first с fallback в кэш
- Изображения: Cache-first
- Аудио: Stale-while-revalidate для полных файлов
- Скрипты/стили: Cache-first

**Особые функции**:
- Управление офлайн-кэшем по сообщениям
- Background Sync для докачки ресурсов
- Перевалидация кэша по расписанию
- Ограничение размера кэша с LRU-стратегией
- Дифференциация стратегий для медленных сетей

### 3.4. Модуль интерфейса пользователя

**Назначение**: Управление визуальным представлением и взаимодействием с пользователем.

**Основные компоненты**:
- Галерея обложек альбомов
- Список треков
- Аудио-плеер с элементами управления
- Система уведомлений
- Модальные окна
- Адаптивная навигация

**Особенности**:
- Анимации и переходы
- Поддержка темной темы
- Адаптивный дизайн для всех устройств
- Доступность (ARIA-атрибуты)
- Поддержка горячих клавиш

## 4. ЛОГИКА ВОСПРОИЗВЕДЕНИЯ

### 4.1. Поток воспроизведения трека

```
[Выбор альбома] → [Загрузка конфигурации] → [Выбор трека] → [Загрузка аудио] → [Воспроизведение]
       │                │                    │                 │                  │
       └─ Кэш SW ◄──────┘                    └─ Кэш SW ◄───────┘                  │
                                                                       [Фоновый режим] ←┐
                                                                              │       │
[Следующий трек по окончании] ←───────────────────────────────────────────────┘       │
       │                                                                               │
[Обработка событий] ←─────────────────────────────────────────────────────────────────┘
```

### 4.2. Обработка фонового режима

```
[Переключение вкладки/блокировка экрана]
        │
        ├─── iOS ────→ [Инициализация AudioContext] → [Продолжение воспроизведения]
        │                    │
        │                    └── [Приостановка UI-анимаций]
        │
        ├─── Android ──→ [Wake Lock] → [Продолжение воспроизведения]
        │                    │
        │                    └── [Приостановка UI-анимаций]
        │
        └─── Desktop ──→ [Проверка Memory Saver] → [Предупреждение пользователю]
                             │
                             └── [Продолжение воспроизведения]
```

### 4.3. Система переходов между треками

**Условия для автоматического перехода**:
1. **Обычный режим**: По окончании текущего трека
2. **Повтор (Repeat)**: Возврат к началу текущего трека
3. **Случайный порядок (Shuffle)**:
   - Создание перемешанного плейлиста
   - Исключение текущего трека из выборки
   - Гарантия уникальности треков в цикле
4. **Только избранное (Favorites Only)**:
   - Фильтрация треков по отметкам "звездочка"
   - Автоматический переход только между избранными

**Приоритеты**:
1. Таймер сна (стоп воспроизведения по времени)
2. Режим "Один трек" (автопереход отключен)
3. Повтор трека
4. Случайный порядок + Только избранное
5. Последовательное воспроизведение

## 5. ИНТЕРФЕЙС ПОЛЬЗОВАТЕЛЯ

### 5.1. Структура интерфейса

```
┌───────────────────────────────────────────────┐
│                 Шапка (Header)                │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │
│  │ Выбор       │  │ Галерея     │  │         │ │
│  │ альбома     │  │ обложек     │  │ Соцсети │ │
│  └─────────────┘  └─────────────┘  └─────────┘ │
├───────────────────────────────────────────────┤
│              Текущий трек (Mini)              │
│  (Отображается при просмотре другого альбома) │
├───────────────────────────────────────────────┤
│              Список треков (Track List)       │
│  ┌─────────────────────────────────────────┐  │
│  │ • Номер трека                           │  │
│  │ • Название трека                        │  │
│  │ • Кнопка "Избранное" (звездочка)        │  │
│  │ • Текущий трек (подсветка)              │  │
│  └─────────────────────────────────────────┘  │
├───────────────────────────────────────────────┤
│              Плеер (Player)                  │
│  ┌─────────────────────────────────────────┐  │
│  │ • Лирика песни                          │  │
│  │ • Прогресс-бар                          │  │
│  │ • Элементы управления (плей/пауза)      │  │
│  │ • Дополнительные функции (повтор и т.д.)│  │
│  └─────────────────────────────────────────┘  │
├───────────────────────────────────────────────┤
│              Нижняя панель (Footer)           │
│  ┌─────────────────────────────────────────┐  │
│  │ • Фильтр избранных треков               │  │
│  │ • Логотип                               │  │
│  │ • Кнопки действий (PWA, скачивание)     │  │
│  │ • Связь/поддержка                       │  │
│  │ • Статус сети                           │  │
│  └─────────────────────────────────────────┘  │
└───────────────────────────────────────────────┘
```

### 5.2. Система визуальных эффектов

**Анимация лирики**:
- Построчная подсветка текущей строки
- Плавные переходы между строками
- Фоновая градиентная анимация
- Автоматическая прокрутка к активной строке

**Пульсация логотипа ("Бит")**:
- Анализ аудио-сигнала через Web Audio API
- Изменение масштаба логотипа в ритме музыки
- Регулируемая интенсивность (100%, 50%, 15%)
- Автоматическое отключение в фоновом режиме

**Галерея обложек**:
- Автоматическая прокрутка между изображениями
- Плавные переходы с эффектом затухания
- Ручное управление стрелками
- Приостановка в фоновом режиме и при экономии энергии

**Ультра-экономичный режим ("Молния")**:
- Полное отключение UI-анимаций
- Приостановка обновления прогресс-бара
- Отключение пульсации логотипа
- Приостановка галереи обложек
- Сохранение состояния между сессиями

### 5.3. Система горячих клавиш

**Основные команды**:
- `K`/`Пробел`: Воспроизведение/Пауза
- `X`: Стоп
- `N`/`P`: Следующий/Предыдущий трек
- `J`/`L`: Перемотка (-10с/+10с)
- `+`/`-`: Увеличение/уменьшение громкости
- `M`: Без звука
- `R`: Повтор трека
- `U`: Случайный порядок
- `F`: Только избранные треки
- `T`: Таймер сна
- `A`: Анимация лирики
- `B`: Пульсация логотипа
- `Y`: Показать/скрыть лирику
- `D`: Добавить/удалить из избранного
- `1`/`2`/`3`: Изменить интенсивность пульсации

**Особенности**:
- Отключение при фокусе на полях ввода
- Контекстная справка по клавише `?`
- Автоматическое закрытие модалок по `Esc`

## 6. ОФЛАЙН-ВОЗМОЖНОСТИ

### 6.1. Стратегии кэширования

**Ядро приложения**:
- HTML-страницы (index.html, news.html)
- Web App Manifest
- Иконки приложения
- Основные скрипты и стили
- Логотипы и базовые изображения

**Данные альбомов**:
- Конфигурационные файлы (config.json)
- Списки треков
- Обложки альбомов (оптимизированные webp)
- Тексты песен (лирика)

**Избранные треки**:
- Аудиофайлы избранных треков
- Связанные метаданные
- Превью изображений

### 6.2. Управление офлайн-кэшем

**Процесс активации**:
```
[Нажатие кнопки "OFFLINE"]
        │
        ├── Проверка поддержки Service Worker
        │
        ├── Формирование списка ресурсов
        │      ├── Базовые файлы приложения
        │      ├── Избранные треки всех альбомов
        │      └── Галереи (webp версии)
        │
        ├── Кэширование ресурсов
        │      ├── Последовательная загрузка
        │      ├── Отображение прогресса
        │      └── Обработка ошибок
        │
        └── Активация офлайн-режима
               ├── Обновление UI
               ├── Сохранение состояния
               └── Background Sync для докачки
```

**Ограничения**:
- Максимальный размер кэша аудио: 150 МБ
- Максимальный размер не-RANGE аудио: 25 МБ (10 МБ при медленном соединении)
- LRU-стратегия при превышении лимита
- Автоматическая очистка устаревших данных

### 6.3. Восстановление после офлайн

**Сценарии**:
1. **Воспроизведение в офлайне**:
   - Использование кэшированных аудиофайлов
   - Отображение кэшированной лирики
   - Фоновая музыка без интернета

2. **Возврат в онлайн**:
   - Проверка обновлений конфигурации
   - Обновление кэша новых треков
   - Синхронизация избранных треков
   - Обновление галерей обложек

3. **Частичная доступность**:
   - Загрузка метаданных при слабом сигнале
   - Потоковое воспроизведение с кэшированием
   - Приоритетное кэширование текущего трека

## 7. ПРОИЗВОДИТЕЛЬНОСТЬ И ОПТИМИЗАЦИЯ

### 7.1. Стратегии загрузки

**Критические ресурсы**:
- CSS и шрифты инлайн в HTML
- Preload ключевых изображений
- Lazy loading для неактивных альбомов
- Код разделен на критический и некритический

**Аудио-оптимизация**:
- Поддержка Range-запросов
- Кэширование фрагментов
- Приоритетная загрузка следующего трека
- Оптимизация для фонового режима

**Изображения**:
- Адаптивные изображения (srcset)
- WebP как основной формат
- Отложенная загрузка (lazy loading)
- Кэширование в Service Worker

### 7.2. Экономия ресурсов

**Энергосбережение**:
- Автоматическое определение saveData
- Отключение анимаций при предпочтении reduced motion
- Троттлинг обновлений UI в фоне
- Приостановка не критичных процессов

**Память**:
- Очистка кэша при превышении лимита
- Удаление старых офлайн-данных
- Оптимизация использования localStorage
- Освобождение аудио-контекстов

**CPU**:
- Отложенное выполнение не критичных задач
- requestIdleCallback для фоновых операций
- Дебаунсинг частых обновлений UI
- Оптимизация анимаций (will-change, transform)

### 7.3. Мониторинг производительности (RUM)

**Отслеживаемые метрики**:
- LCP (Largest Contentful Paint)
- CLS (Cumulative Layout Shift)
- FID/INP (First Input Delay / Interaction to Next Paint)
- TTFB (Time to First Byte)

**Сбор данных**:
- Сэмплирование (100% по умолчанию)
- Отправка через navigator.sendBeacon
- Fallback на fetch при отсутствии sendBeacon
- Локальное логирование при отсутствии endpoint

## 8. БЕЗОПАСНОСТЬ

### 8.1. Защита данных

**Хранилище**:
- Локальное хранение только нечувствительных данных
- Шифрование критичных данных (при необходимости)
- Ограничение доступа к localStorage
- Очистка данных при удалении приложения

**Сетевые запросы**:
- Валидация URL перед загрузкой
- Ограничение CORS только доверенными доменами
- Проверка MIME-типов
- Защита от XSS в динамическом контенте

### 8.2. Защита воспроизведения

**Аудио-ресурсы**:
- Проверка доступности перед воспроизведением
- Обработка сетевых ошибок
- Защита от бесконечных загрузок
- Лимиты на размер кэшируемых файлов

**Медиа-сессии**:
- Валидация метаданных
- Ограничение действий в фоновом режиме
- Защита от несанкционированного доступа
- Корректное освобождение ресурсов

## 9. ДЕПЛОЙ И CI/CD

### 9.1. Workflow GitHub Actions

**Сборка и деплой**:
```
[Push в ветку main]
        │
        ├── Checkout кода
        │
        ├── Установка Node.js
        │
        ├── Валидация конфигурации
        │      ├── Проверка albums.json
        │      ├── Валидация галерей
        │      └── Проверка ссылок
        │
        ├── Генерация .nojekyll
        │
        ├── Загрузка артефактов
        │
        └── Деплой на GitHub Pages
               ├── Регистрация страницы
               ├── Проверка статуса
               └── Уведомление о результатах
```

**Генерация контекста**:
```
[Push в ветку main]
        │
        ├── Checkout кода
        │
        ├── Установка Node.js
        │
        ├── Генерация .meta/project-full.txt
        │      ├── Сборка структуры проекта
        │      ├── Извлечение содержимого файлов
        │      └── Форматирование вывода
        │
        ├── Генерация .meta/project-adaptive.txt
        │      ├── Ограничение по количеству строк
        │      └── Приоритезация файлов
        │
        └── Коммит изменений в .meta/
```

### 9.2. Версионирование

**Стратегия**:
- Семантическое версионирование (major.minor.patch)
- Версия указана в index.html и service-worker.js
- Автоматическое обновление Service Worker
- Сохранение состояния между версиями

**Обновление приложения**:
```
[Обнаружение новой версии Service Worker]
        │
        ├── Предложение обновить
        │
        ├── Сохранение состояния воспроизведения
        │      ├── Позиция трека
        │      ├── Текущий альбом/трек
        │      └── Настройки плеера
        │
        ├── Пропуск ожидания старого Service Worker
        │
        ├── Активация нового Service Worker
        │
        └── Восстановление состояния после перезагрузки
```

## 10. ПЛАНЫ РАЗВИТИЯ И ДОПОЛНИТЕЛЬНЫЕ ФУНКЦИИ

### 10.1. Текущие возможности

**Музыкальный плеер**:
- Фоновое воспроизведение на всех устройствах
- Автоматический переход на следующий трек
- Управление с лок-скрина и гарнитуры
- Отображение обложки на лок-скрине
- Карточка уведомлений с управлениями
- Поддержка Media Session API

**Управление контентом**:
- Динамическая загрузка альбомов
- Система избранных треков
- Галерея обложек с автопрокруткой
- Отображение лирики песен
- Поиск по трекам
- Сортировка треков

**Офлайн-режим**:
- Кэширование выбранных треков
- Работа приложения без интернета
- Фоновое кэширование при подключении
- Управление размером офлайн-кэша
- Визуальная индикация офлайн-статуса

**Пользовательский опыт**:
- Адаптивный интерфейс для всех устройств
- Темная тема по умолчанию
- Горячие клавиши для управления
- Визуальные эффекты (анимация лирики, пульсация логотипа)
- Ультра-экономичный режим для слабых устройств
- Подсказки по использованию (Memory Saver в Chrome)
- PWA-установка на устройство

### 10.2. Интеграции

**Социальные сети**:
- Встраивание VK плейлистов
- Ссылки на Яндекс Музыку
- Telegram-канал
- Кнопки поделиться в соцсетях

**Сторонние сервисы**:
- Поддержка экспорта треков
- Интеграция с системными медиа-контролями
- Совместимость с караоке-приложениями
- Поддержка различных аудио-форматов

### 10.3. Планы развития

**Ближайшие улучшения**:
- Улучшение алгоритма фонового воспроизведения
- Оптимизация использования памяти
- Расширение поддержки форматов
- Улучшение алгоритма экономии энергии
- Добавление плейлистов пользователя

**Долгосрочные планы**:
- Межплатформенная синхронизация
- Социальные функции (совместное прослушивание)
- Расширенная аналитика для пользователей
- Интеграция с музыкальными сервисами
- Расширенная поддержка подкастов

## ЗАКЛЮЧЕНИЕ

Приложение "Витрина Разбита" представляет собой полнофункциональное музыкальное PWA с продвинутыми возможностями фонового воспроизведения, офлайн-доступа и оптимизации для различных устройств. Архитектура приложения построена на современных веб-технологиях с акцентом на производительность, надежность и пользовательский опыт.

Ключевые особенности:
1. **Надежное фоновое воспроизведение** на всех платформах
2. **Гибкая система управления** с поддержкой горячих клавиш
3. **Адаптивный интерфейс** для мобильных и десктоп устройств
4. **Продвинутый офлайн-режим** с интеллектуальным кэшированием
5. **Оптимизация для слабых устройств** через ультра-экономичный режим
6. **Полная PWA-функциональность** с установкой на устройство
7. **Продуманная система анимаций** без ущерба для производительности

Приложение готово к использованию в продакшене и имеет масштабируемую архитектуру для дальнейшего развития и добавления новых функций.",
    m.madeWith,
    ""
  ].join("\n");
}

// -------------------- СТРУКТУРА ПРОЕКТА (дерево) --------------------
function buildFullTree() {
  const lines = [];
  lines.push(path.basename(ROOT) + "/");

  function walk(dir, prefix = "") {
    let entries = [];
    try { entries = fs.readdirSync(dir, { withFileTypes: true }); } catch { return; }

    const visible = entries
      .filter(e => !isExcludedForTree(toUnix(path.relative(ROOT, path.join(dir, e.name)))))
      .sort((a, b) => (a.isDirectory() !== b.isDirectory() ? (a.isDirectory() ? -1 : 1) : a.name.localeCompare(b.name)));

    visible.forEach((e, i) => {
      const isLast = i === visible.length - 1;
      const branch = isLast ? "└── " : "├── ";
      lines.push(prefix + branch + e.name + (e.isDirectory() ? "/" : ""));
      if (e.isDirectory()) {
        walk(path.join(dir, e.name), prefix + (isLast ? "    " : "│   "));
      }
    });
  }

  walk(ROOT);
  return lines.join("\n") + "\n\n";
}

// -------------------- Секция «ФАЙЛЫ» --------------------
function getPriority(rel) {
  const u = toUnix(rel);
  for (const [lvl, rules] of Object.entries(PRIORITY)) {
    if (rules.some(re => re.test(u))) return lvl;
  }
  return "low";
}

function groupFilesByPriority() {
  const all = listTextFilesForContent(); // уже исключены assets/.meta и прочие по EXCLUDE_FILES_PATTERNS
  return {
    critical: all.filter(f => getPriority(f) === "critical"),
    high:     all.filter(f => getPriority(f) === "high"),
    medium:   all.filter(f => getPriority(f) === "medium"),
    low:      all.filter(f => getPriority(f) === "low"),
  };
}

function fileBlock(rel) {
  return [
    "//=================================================",
    `// FILE: /${toUnix(rel)}`,
    readText(rel),
    ""
  ].join("\n");
}

// -------------------- Заголовок отчёта --------------------
function headerBlock() {
  const now = new Date().toISOString().replace("T"," ").slice(0,19) + " UTC";
  return [
    rulesBlock(),
    metaBlock(),
    "СТРУКТУРА ПРОЕКТА:",
    buildFullTree(),
    `Сгенерировано: ${now}`,
    ""
  ].join("\n");
}

// -------------------- Генераторы --------------------
function generateFull() {
  let out = headerBlock();

  const groups = groupFilesByPriority();
  const order = ["critical", "high", "medium", "low"];
  for (const lvl of order) {
    for (const f of groups[lvl]) {
      out += fileBlock(f);
    }
  }

  // БЕЗ блока «Критичные логи»
  return out;
}

function generateAdaptive() {
  let out = headerBlock();
  let cur = countLines(out);
  const max = MAX_LINES;

  const groups = groupFilesByPriority();
  const order = ["critical", "high", "medium"]; // low пропускаем в adaptive чаще всего

  for (const lvl of order) {
    for (const f of groups[lvl]) {
      const block = fileBlock(f);
      const L = countLines(block);
      if (cur + L > max) {
        out += "\n// ... (truncate)\n";
        return out;
      }
      out += block; cur += L;
    }
  }

  // БЕЗ блока «Критичные логи»
  return out;
}

// -------------------- MAIN --------------------
function main() {
  if (MODE === "full" || MODE === "both") {
    fs.writeFileSync(FULL_FILE, generateFull(), "utf8");
    console.log(`✅ ${FULL_FILE}`);
  }
  if (MODE === "adaptive" || MODE === "both") {
    fs.writeFileSync(ADAPTIVE_FILE, generateAdaptive(), "utf8");
    console.log(`✅ ${ADAPTIVE_FILE}`);
  }
}

try { main(); } catch (e) { console.error("❌", e); process.exit(1); }
